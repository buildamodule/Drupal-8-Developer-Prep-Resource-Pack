<?php

/**
 * @file
 * Allows entities to be translated into different languages.
 */

use Drupal\Core\Language\Language;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Entity\EntityFormControllerInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityNG;

/**
 * Implements hook_help().
 */
function content_translation_help($path, $arg) {
  switch ($path) {
    case 'admin/help#content_translation':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The Content Translation module allows you to create and manage translations for your Drupal site content. You can specify which elements need to be translated at the content-type level for content items and comments, at the vocabulary level for taxonomy terms, and at the site level for user accounts. Other modules may provide additional elements that can be translated. For more information, see the online handbook entry for <a href="!url">Content Translation</a>.', array('!url' => 'http://drupal.org/documentation/modules/translation_entity')) . '</p>';
      $output .= '<h3>' . t('Uses') . '</h3>';
      $output .= '<dl>';
      $output .= '<dt>' . t('Enabling translation') . '</dt>';
      $output .= '<dd><p>' . t('Before you can translate content, there must be at least two languages added on the <a href="!url">languages administration</a> page.', array('!url' => url('admin/config/regional/language'))) . '</p>';
      $output .= '<p>' . t('After adding languages, <a href="!url">configure translation</a>.', array('!url' => url('admin/config/regional/content-language'))) . '</p>';
      $output .= '<dt>' . t('Translating content') . '</dt>';
      $output .= '<dd>' . t('After enabling translation you can create a new piece of content, or edit existing content and assign it a language. Then, you will see a <em>Translate</em> tab or link that will gives an overview of the translation status for the current content. From there, you can add translations and edit or delete existing translations. This process is similar for every translatable element on your site, such as taxonomy terms, comments or user accounts.') . '</dd>';
      $output .= '<dt>' . t('Changing source language') . '</dt>';
      $output .= '<dd>' . t('When there are two or more possible source languages, selecting a <em>Source language</em> will repopulate the form using the specified source\'s values. For example, French is much closer to Spanish than to Chinese, so changing the French translation\'s source language to Spanish can assist translators.') . '</dd>';
      $output .= '<dt>' . t('Maintaining translations') . '</dt>';
      $output .= '<dd>' . t('If editing content in one language requires that translated versions also be updated to reflect the change, use the <em>Flag other translations as outdated</em> check box to mark the translations as outdated and in need of revision.') . '</dd>';
      $output .= '<dt>' . t('Translation permissions') . '</dt>';
      $output .= '<dd>' . t('The Content Translation module makes a basic set of permissions available. Additional <a href="@permissions">permissions</a> are made available after translation is enabled for each translatable element.', array('@permissions' => url('admin/people/permissions', array('fragment' => 'module-content_translation')))) . '</dd>';
      $output .= '</dl>';
      return $output;

    case 'admin/config/regional/content-language':
      $output = '';
      if (!language_multilingual()) {
        $output .= '<br/>' . t('Before you can translate content, there must be at least two languages added on the <a href="!url">languages administration</a> page.', array('!url' => url('admin/config/regional/language')));
      }
      return $output;
  }
}

/**
 * Implements hook_module_implements_alter().
 */
function content_translation_module_implements_alter(&$implementations, $hook) {
  switch ($hook) {
    // Move some of our hook implementations to the end of the list.
    case 'menu_alter':
    case 'entity_info_alter':
      $group = $implementations['content_translation'];
      unset($implementations['content_translation']);
      $implementations['content_translation'] = $group;
      break;
  }
}

/**
 * Implements hook_language_type_info_alter().
 */
function content_translation_language_types_info_alter(array &$language_types) {
  // Make content language negotiation configurable by removing the 'locked'
  // flag.
  $language_types[Language::TYPE_CONTENT]['locked'] = FALSE;
  unset($language_types[Language::TYPE_CONTENT]['fixed']);
}

/**
 * Implements hook_entity_info_alter().
 */
function content_translation_entity_info_alter(array &$entity_info) {
  // Provide defaults for translation info.
  foreach ($entity_info as $entity_type => &$info) {
    if (empty($info['translatable'])) {
      continue;
    }

    if (!isset($info['translation']['content_translation'])) {
      $info['translation']['content_translation'] = array();
    }

    // Every fieldable entity type must have a translation controller class, no
    // matter if it is enabled for translation or not. As a matter of fact we
    // might need it to correctly switch field translatability when a field is
    // shared accross different entities.
    $info['controllers'] += array('translation' => 'Drupal\content_translation\ContentTranslationController');

    // If no menu base path is provided we default to the usual
    // "entity_type/%entity_type" pattern.
    if (!isset($info['menu_base_path'])) {
      $path = "$entity_type/%$entity_type";
      $info['menu_base_path'] = $path;
    }

    $path = $info['menu_base_path'];

    $info += array(
      'menu_view_path' => $path,
      'menu_edit_path' => "$path/edit",
      'menu_path_wildcard' => "%$entity_type",
    );

    $entity_position = count(explode('/', $path)) - 1;
    $info['translation']['content_translation'] += array(
      'access_callback' => 'content_translation_translate_access',
      'access_arguments' => array($entity_position),
    );
  }
}

/**
 * Implements hook_entity_bundle_info_alter().
 */
function content_translation_entity_bundle_info_alter(&$bundles) {
  foreach ($bundles as $entity_type => &$info) {
    foreach ($info as $bundle => &$bundle_info) {
      $enabled = content_translation_get_config($entity_type, $bundle, 'enabled');
      $bundle_info['translatable'] = !empty($enabled);
    }
  }
}

/**
 * Implements hook_menu().
 */
function content_translation_menu() {
  $items = array();

  // Create tabs for all possible entity types.
  foreach (entity_get_info() as $entity_type => $info) {
    // Provide the translation UI only for enabled types.
    if (content_translation_enabled($entity_type)) {
      $path = $info['menu_base_path'];
      $entity_position = count(explode('/', $path)) - 1;
      $keys = array_flip(array('theme_callback', 'theme_arguments', 'access_callback', 'access_arguments', 'load_arguments'));
      $menu_info = array_intersect_key($info['translation']['content_translation'], $keys) + array('file' => 'content_translation.pages.inc');
      $item = array();

      // Plugin annotations cannot contain spaces, thus we need to restore them
      // from underscores.
      foreach ($menu_info as $key => $value) {
        $item[str_replace('_', ' ', $key)] = $value;
      }

      $items["$path/translations"] = array(
        'title' => 'Translate',
        'page callback' => 'content_translation_overview',
        'page arguments' => array($entity_position),
        'type' => MENU_LOCAL_TASK,
        'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
        'weight' => 2,
      ) + $item;

      $items["$path/translations/overview"] = array(
        'title' => 'Overview',
        'type' => MENU_DEFAULT_LOCAL_TASK,
        'weight' => 0,
      );

      // Add translation callback.
      // @todo Add the access callback instead of replacing it as soon as the
      // routing system supports multiple callbacks.
      $language_position = $entity_position + 3;
      $args = array($entity_position, $language_position, $language_position + 1);
      $items["$path/translations/add/%language/%language"] = array(
        'title' => 'Add',
        'page callback' => 'content_translation_add_page',
        'page arguments' => $args,
        'access callback' => 'content_translation_add_access',
        'access arguments' => $args,
        'type' => MENU_LOCAL_TASK,
        'weight' => 1,
      ) + $item;

      // Edit translation callback.
      $args = array($entity_position, $language_position);
      $items["$path/translations/edit/%language"] = array(
        'title' => 'Edit',
        'page callback' => 'content_translation_edit_page',
        'page arguments' => $args,
        'access callback' => 'content_translation_edit_access',
        'access arguments' => $args,
        'type' => MENU_LOCAL_TASK,
        'weight' => 1,
      ) + $item;

      // Delete translation callback.
      $items["$path/translations/delete/%language"] = array(
        'title' => 'Delete',
        'page callback' => 'drupal_get_form',
        'page arguments' => array('content_translation_delete_confirm', $entity_position, $language_position),
        'access callback' => 'content_translation_delete_access',
        'access arguments' => $args,
      ) + $item;
    }
  }

  $items['admin/config/regional/content_translation/translatable/%'] = array(
    'title' => 'Confirm change in translatability.',
    'description' => 'Confirm page for changing field translatability.',
    'route_name' => 'content_translation_translatable',
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function content_translation_menu_alter(array &$items) {
  // Check that the declared menu base paths are actually valid.
  foreach (entity_get_info() as $entity_type => $info) {
    if (content_translation_enabled($entity_type)) {
      $path = $info['menu_base_path'];

      // If the base path is not defined we cannot provide the translation UI
      // for this entity type. In some cases the actual base path might not have
      // a menu loader associated, hence we need to check also for the plain "%"
      // variant. See for instance comment_menu().
      if (!isset($items[$path]) && !isset($items["$path/edit"])
          && !isset($items[_content_translation_menu_strip_loaders($path)])) {
        unset(
          $items["$path/translations"],
          $items["$path/translations/add/%language/%language"],
          $items["$path/translations/delete/%language"]
        );
        $t_args = array('@entity_type' => isset($info['label']) ? $info['label'] : $entity_type);
        watchdog('content translation', 'The entities of type @entity_type do not define a valid base path: it will not be possible to translate them.', $t_args, WATCHDOG_WARNING);
      }
      else {
        $entity_position = count(explode('/', $path)) - 1;
        $edit_path = $info['menu_edit_path'];

        if (isset($items[$edit_path])) {
          // If the edit path is a default local task we need to find the parent
          // item.
          $edit_path_split = explode('/', $edit_path);
          do {
            $entity_form_item = &$items[implode('/', $edit_path_split)];
            array_pop($edit_path_split);
          }
          while (!empty($entity_form_item['type']) && $entity_form_item['type'] == MENU_DEFAULT_LOCAL_TASK);

          // Make the "Translate" tab follow the "Edit" one when possibile.
          if (isset($entity_form_item['weight'])) {
            $items["$path/translations"]['weight'] = $entity_form_item['weight'] + 0.01;
          }
        }
      }
    }
  }
}

/**
 * Strips out menu loaders from the given path.
 *
 * @param string $path
 *   The path to process.
 *
 * @return
 *   The given path where all the menu loaders are replaced with "%".
 */
function _content_translation_menu_strip_loaders($path) {
  return preg_replace('|%[^/]+|', '%', $path);
}

/**
 * Access callback for the translation overview page.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity whose translation overview should be displayed.
 */
function content_translation_translate_access(EntityInterface $entity) {
  $entity_type = $entity->entityType();
  return empty($entity->getUntranslated()->language()->locked) && language_multilingual() && $entity->isTranslatable() &&
    (user_access('create content translations') || user_access('update content translations') || user_access('delete content translations'));
}

/**
 * Checks whether the given user can view the specified translation.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity whose translation overview should be displayed.
 * @param $langcode
 *   The language code of the translation to be displayed.
 * @param \Drupal\Core\Session\AccountInterface $account
 *   (optional) The account for which view access should be checked. Defaults to
 *   the current user.
 */
function content_translation_view_access(EntityInterface $entity, $langcode, AccountInterface $account = NULL) {
  $entity_type = $entity->entityType();
  return !empty($entity->translation[$langcode]['status']) || user_access('translate any entity', $account) || user_access("translate $entity_type entities", $account);
}

/**
 * Access callback for the translation addition page.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity being translated.
 * @param \Drupal\Core\Language\Language $source
 *   (optional) The language of the values being translated. Defaults to the
 *   entity language.
 * @param \Drupal\Core\Language\Language $target
 *   (optional) The language of the translated values. Defaults to the current
 *   content language.
 */
function content_translation_add_access(EntityInterface $entity, Language $source = NULL, Language $target = NULL) {
  $source = !empty($source) ? $source : $entity->language();
  $target = !empty($target) ? $target : language(Language::TYPE_CONTENT);
  $translations = $entity->getTranslationLanguages();
  $languages = language_list();
  return $source->id != $target->id && isset($languages[$source->id]) && isset($languages[$target->id]) && !isset($translations[$target->id]) && content_translation_access($entity, 'create');
}

/**
 * Access callback for the translation edit page.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity being translated.
 * @param \Drupal\Core\Language\Language $language
 *   (optional) The language of the translated values. Defaults to the current
 *   content language.
 */
function content_translation_edit_access(EntityInterface $entity, Language $language = NULL) {
  $language = !empty($language) ? $language : language(Language::TYPE_CONTENT);
  $translations = $entity->getTranslationLanguages();
  $languages = language_list();
  return isset($languages[$language->id]) && $language->id != $entity->getUntranslated()->language()->id && isset($translations[$language->id]) && content_translation_access($entity, 'update');
}

/**
 * Access callback for the translation delete page.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity being translated.
 * @param \Drupal\Core\Language\Language $language
 *   (optional) The language of the translated values. Defaults to the current
 *   content language.
 */
function content_translation_delete_access(EntityInterface $entity, Language $language = NULL) {
  $language = !empty($language) ? $language : language(Language::TYPE_CONTENT);
  $translations = $entity->getTranslationLanguages();
  $languages = language_list();
  return isset($languages[$language->id]) && $language->id != $entity->getUntranslated()->language()->id && isset($translations[$language->id]) && content_translation_access($entity, 'delete');
}

/**
 * Implements hook_library_info().
 */
function content_translation_library_info() {
  $path = drupal_get_path('module', 'content_translation');
  $libraries['drupal.content_translation.admin'] = array(
    'title' => 'Content translation UI',
    'version' => VERSION,
    'js' => array(
      $path . '/content_translation.admin.js' => array(),
    ),
    'css' => array(
      $path . '/css/content_translation.admin.css' => array(),
    ),
    'dependencies' => array(
      array('system', 'jquery'),
      array('system', 'drupal'),
      array('system', 'jquery.once'),
    ),
  );

  return $libraries;
}

/**
 * Returns the key name used to store the configuration setting.
 *
 * Based on the entity type and bundle, the keys used to store configuration
 * will have a common root name.
 *
 * @param string $entity_type
 *   The type of the entity the setting refers to.
 * @param string $bundle
 *   The bundle of the entity the setting refers to.
 * @param string $setting
 *   The name of the setting.
 *
 * @return string
 *   The key name of the configuration setting.
 *
 * @todo Generalize this logic so that it is available to any module needing
 *   per-bundle configuration.
 */
function content_translation_get_config_key($entity_type, $bundle, $setting) {
  $entity_type = preg_replace('/[^0-9a-zA-Z_]/', "_", $entity_type);
  $bundle = preg_replace('/[^0-9a-zA-Z_]/', "_", $bundle);
  return $entity_type . '.' . $bundle . '.content_translation.' . $setting;
}

/**
 * Retrieves the value for the specified setting.
 *
 * @param string $entity_type
 *   The type of the entity the setting refer to.
 * @param string $bundle
 *   The bundle of the entity the setting refer to.
 * @param string $setting
 *   The name of the setting.
 *
 * @returns mixed
 *   The stored value for the given setting.
 */
function content_translation_get_config($entity_type, $bundle, $setting) {
  $key = content_translation_get_config_key($entity_type, $bundle, $setting);
  return Drupal::config('content_translation.settings')->get($key);
}

/**
 * Stores the given value for the specified setting.
 *
 * @param string $entity_type
 *   The type of the entity the setting refer to.
 * @param string $bundle
 *   The bundle of the entity the setting refer to.
 * @param string $setting
 *   The name of the setting.
 * @param $value
 *   The value to be stored for the given setting.
 */
function content_translation_set_config($entity_type, $bundle, $setting, $value) {
  $key = content_translation_get_config_key($entity_type, $bundle, $setting);
  return Drupal::config('content_translation.settings')->set($key, $value)->save();
}

/**
 * Determines whether the given entity type is translatable.
 *
 * @param string $entity_type
 *   The type of the entity.
 * @param string $bundle
 *   (optional) The bundle of the entity. If no bundle is provided, all the
 *   available bundles are checked.
 *
 * @returns
 *   TRUE if the specified bundle is translatable. If no bundle is provided
 *   returns TRUE if at least one of the entity bundles is translatable.
 */
function content_translation_enabled($entity_type, $bundle = NULL) {
  $enabled = FALSE;
  $info = entity_get_info($entity_type);

  if (!empty($info['translatable'])) {
    $bundles = !empty($bundle) ? array($bundle) : array_keys(entity_get_bundles($entity_type));
    foreach ($bundles as $bundle) {
      if (content_translation_get_config($entity_type, $bundle, 'enabled')) {
        $enabled = TRUE;
        break;
      }
    }
  }

  return $enabled;
}

/**
 * Returns all the translatable entity types.
 *
 * @return array
 *   An array of entity types keyed by entity type.
 */
function content_translation_types_translatable() {
  $entity_types = &drupal_static(__FUNCTION__, array());

  foreach (entity_get_info() as $entity_type => $info) {
    if (content_translation_enabled($entity_type)) {
      // Lazy load router items.
      if (!isset($items)) {
        $items = menu_get_router();
      }
      // Check whether the required paths are defined. We need to strip out the
      // menu loader and replace it with a plain "%" as router items have no
      // menu loader in them.
      $path = _content_translation_menu_strip_loaders($info['menu_base_path']);
      if (!empty($items[$path]) && !empty($items[$path . '/translations'])) {
        $entity_types[$entity_type] = $entity_type;
      }
    }
  }

  return $entity_types;
}

/**
 * Content translation controller factory.
 *
 * @param string $entity_type
 *   The type of the entity being translated.
 *
 * @return \Drupal\content_translation\ContentTranslationControllerInterface
 *   An instance of the content translation controller interface.
 */
function content_translation_controller($entity_type) {
  $entity_info = entity_get_info($entity_type);
  // @todo Throw an exception if the key is missing.
  return new $entity_info['controllers']['translation']($entity_type, $entity_info);
}

/**
 * Returns the entity form controller for the given form.
 *
 * @param array $form_state
 *   The form state array holding the entity form controller.
 *
 * @return \Drupal\Core\Entity\EntityFormControllerInterface;
 *   An instance of the content translation form interface or FALSE if not an
 *   entity form.
 */
function content_translation_form_controller(array $form_state) {
  return isset($form_state['controller']) && $form_state['controller'] instanceof EntityFormControllerInterface ? $form_state['controller'] : FALSE;
}

/**
 * Checks whether a content translation is accessible.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity to be accessed.
 * @param $op
 *   The operation to be performed on the translation. Possible values are:
 *   - "view"
 *   - "update"
 *   - "delete"
 *   - "create"
 *
 * @return
 *   TRUE if the current user is allowed to view the translation.
 */
function content_translation_access(EntityInterface $entity, $op) {
  return content_translation_controller($entity->entityType())->getTranslationAccess($entity, $op) ;
}

/**
 * Implements hook_permission().
 */
function content_translation_permission() {
  $permission = array(
    'administer content translation' => array(
      'title' => t('Administer translation settings'),
      'description' => t('Configure translatability of entities and fields.'),
    ),
    'create content translations' => array(
      'title' => t('Create translations'),
    ),
    'update content translations' => array(
      'title' => t('Edit translations'),
    ),
    'delete content translations' => array(
      'title' => t('Delete translations'),
    ),
    'translate any entity' => array(
      'title' => t('Translate any entity'),
    ),
  );

  // Create a translate permission for each enabled entity type and (optionally)
  // bundle.
  foreach (entity_get_info() as $entity_type => $info) {
    if (!empty($info['permission_granularity'])) {
      $t_args = array('@entity_label' => drupal_strtolower(t($info['label'])));

      switch ($info['permission_granularity']) {
        case 'bundle':
          foreach (entity_get_bundles($entity_type) as $bundle => $bundle_info) {
            if (content_translation_enabled($entity_type, $bundle)) {
              $t_args['%bundle_label'] = isset($bundle_info['label']) ? $bundle_info['label'] : $bundle;
              $permission["translate $bundle $entity_type"] = array(
                'title' => t('Translate %bundle_label @entity_label', $t_args),
              );
            }
          }
          break;

        case 'entity_type':
          if (content_translation_enabled($entity_type)) {
            $permission["translate $entity_type"] = array(
              'title' => t('Translate @entity_label', $t_args),
            );
          }
          break;
      }
    }
  }

  return $permission;
}

/**
 * Implements hook_form_alter().
 */
function content_translation_form_alter(array &$form, array &$form_state) {
  if (($form_controller = content_translation_form_controller($form_state)) && ($entity = $form_controller->getEntity()) && !$entity->isNew() && $entity->isTranslatable()) {
    $controller = content_translation_controller($entity->entityType());
    $controller->entityFormAlter($form, $form_state, $entity);

    // @todo Move the following lines to the code generating the property form
    //   elements once we have an official #multilingual FAPI key.
    $translations = $entity->getTranslationLanguages();
    $form_langcode = $form_controller->getFormLangcode($form_state);

    // Handle fields shared between translations when there is at least one
    // translation available or a new one is being created.
    if (!$entity->isNew() && (!isset($translations[$form_langcode]) || count($translations) > 1)) {
      $entity = $entity->getNGEntity();
      if ($entity instanceof EntityNG) {
        foreach ($entity->getPropertyDefinitions() as $property_name => $definition) {
          if (isset($form[$property_name])) {
            $form[$property_name]['#multilingual'] = !empty($definition['translatable']);
          }
        }
      }
      else {
        foreach (field_info_instances($entity->entityType(), $entity->bundle()) as $instance) {
          $field_name = $instance['field_name'];
          $field = field_info_field($field_name);
          $form[$field_name]['#multilingual'] = !empty($field['translatable']);
        }
      }
    }

  }
}

/**
 * Implements hook_field_language_alter().
 *
 * Performs language fallback for unaccessible translations.
 */
function content_translation_field_language_alter(&$display_language, $context) {
  $entity = $context['entity'];
  $entity_type = $entity->entityType();

  if (isset($entity->translation[$context['langcode']]) && $entity->isTranslatable() && !content_translation_view_access($entity, $context['langcode'])) {
    $instances = field_info_instances($entity_type, $entity->bundle());
    // Avoid altering the real entity.
    $entity = clone($entity);
    $entity_langcode = $entity->getUntranslated()->language()->id;

    foreach ($entity->translation as $langcode => $translation) {
      if ($langcode == $context['langcode'] || !content_translation_view_access($entity, $langcode)) {
        // Unset unaccessible field translations: if the field is untranslatable
        // unsetting a language different from Language::LANGCODE_NOT_SPECIFIED has no
        // effect.
        foreach ($instances as $instance) {
          // @todo BC entities have the same value accessibile both with the
          //   entity language and with Language::LANGCODE_DEFAULT. We need need to unset
          //   both until we remove the BC layer.
          if ($langcode == $entity_langcode) {
            unset($entity->{$instance['field_name']}[Language::LANGCODE_DEFAULT]);
          }
          unset($entity->{$instance['field_name']}[$langcode]);
        }
      }
    }

    // Find the new fallback values.
    field_language_fallback($display_language, $entity, $context['langcode']);
  }
}

/**
 * Implements hook_entity_load().
 */
function content_translation_entity_load(array $entities, $entity_type) {
  $enabled_entities = array();

  if (content_translation_enabled($entity_type)) {
    foreach ($entities as $entity) {
      if ($entity->isTranslatable()) {
        $enabled_entities[$entity->id()] = $entity;
      }
    }
  }

  if (!empty($enabled_entities)) {
    content_translation_load_translation_metadata($enabled_entities, $entity_type);
  }
}

/**
 * Loads translation data into the given entities.
 *
 * @param array $entities
 *   The entities keyed by entity ID.
 * @param string $entity_type
 *   The type of the entities.
 */
function content_translation_load_translation_metadata(array $entities, $entity_type) {
  $query = 'SELECT * FROM {content_translation} te WHERE te.entity_type = :entity_type AND te.entity_id IN (:entity_id)';
  $result = db_query($query, array(':entity_type' => $entity_type, ':entity_id' => array_keys($entities)));
  $exclude = array('entity_type', 'entity_id', 'langcode');
  foreach ($result as $record) {
    $entity = $entities[$record->entity_id];
    // @todo Declare these as entity (translation?) properties.
    foreach ($record as $field_name => $value) {
      if (!in_array($field_name, $exclude)) {
        $langcode = $record->langcode;
        $entity->translation[$langcode][$field_name] = $value;
        if (!$entity->hasTranslation($langcode)) {
          $entity->initTranslation($langcode);
        }
      }
    }
  }
}

/**
 * Implements hook_entity_insert().
 */
function content_translation_entity_insert(EntityInterface $entity) {
  // Only do something if translation support for the given entity is enabled.
  if (!$entity->isTranslatable()) {
    return;
  }

  $fields = array('entity_type', 'entity_id', 'langcode', 'source', 'outdated', 'uid', 'status', 'created', 'changed');
  $query = db_insert('content_translation')->fields($fields);

  foreach ($entity->getTranslationLanguages() as $langcode => $language) {
    $translation = isset($entity->translation[$langcode]) ? $entity->translation[$langcode] : array();

    $translation += array(
      'source' => '',
      'uid' => $GLOBALS['user']->id(),
      'outdated' => FALSE,
      'status' => TRUE,
      'created' => REQUEST_TIME,
      'changed' => REQUEST_TIME,
    );

    $translation['entity_type'] = $entity->entityType();
    $translation['entity_id'] = $entity->id();
    $translation['langcode'] = $langcode;

    // Reorder values to match the schema.
    $values = array();
    foreach ($fields as $field_name) {
      $value = is_bool($translation[$field_name]) ? intval($translation[$field_name]) : $translation[$field_name];
      $values[$field_name] = $value;
    }
    $query->values($values);
  }

  $query->execute();
}

/**
 * Implements hook_entity_delete().
 */
function content_translation_entity_delete(EntityInterface $entity) {
  // Only do something if translation support for the given entity is enabled.
  if (!$entity->isTranslatable()) {
    return;
  }

  db_delete('content_translation')
    ->condition('entity_type', $entity->entityType())
    ->condition('entity_id', $entity->id())
    ->execute();
}

/**
 * Implements hook_entity_update().
 */
function content_translation_entity_update(EntityInterface $entity) {
  // Only do something if translation support for the given entity is enabled.
  if (!$entity->isTranslatable()) {
    return;
  }

  // Delete and create to ensure no stale value remains behind.
  content_translation_entity_delete($entity);
  content_translation_entity_insert($entity);
}

/**
 * Implements hook_field_extra_fields().
 */
function content_translation_field_extra_fields() {
  $extra = array();

  foreach (entity_get_info() as $entity_type => $info) {
    foreach (entity_get_bundles($entity_type) as $bundle => $bundle_info) {
      if (content_translation_enabled($entity_type, $bundle)) {
        $extra[$entity_type][$bundle]['form']['translation'] = array(
          'label' => t('Translation'),
          'description' => t('Translation settings'),
          'weight' => 10,
        );
      }
    }
  }

  return $extra;
}

/**
 * Implements hook_form_FORM_ID_alter() for 'field_ui_field_edit_form'.
 */
function content_translation_form_field_ui_field_edit_form_alter(array &$form, array &$form_state, $form_id) {
  $field = $form['#field'];
  $field_name = $field['field_name'];
  $translatable = $field['translatable'];
  $label = t('Field translation');

  if ($field->hasData()) {
    $form['field']['translatable'] = array(
      '#type' => 'item',
      '#title' => $label,
      '#attributes' => array('class' => 'translatable'),
      'link' => array(
        '#type' => 'link',
        '#prefix' => t('This field has data in existing content.') . ' ',
        '#title' => !$translatable ? t('Enable translation') : t('Disable translation'),
        '#href' => 'admin/config/regional/content_translation/translatable/' . $field_name,
        '#options' => array('query' => drupal_get_destination()),
        '#access' => user_access('administer content translation'),
      ),
    );
  }
  else {
    $form['field']['translatable'] = array(
      '#type' => 'checkbox',
      '#title' => t('Users may translate this field.'),
      '#default_value' => $translatable,
    );
  }

  $form['field']['translatable']['#weight'] = 20;
}

/**
 * Implements hook_form_FORM_ID_alter() for 'field_ui_field_instance_edit_form'.
 */
function content_translation_form_field_ui_field_instance_edit_form_alter(array &$form, array &$form_state, $form_id) {
  if ($form['#field']['translatable']) {
    module_load_include('inc', 'content_translation', 'content_translation.admin');
    $element = content_translation_field_sync_widget($form['#field'], $form['#instance']);
    if ($element) {
      $form['instance']['settings']['translation_sync'] = $element;
    }
  }
}

/**
 * Implements hook_field_info_alter().
 */
function content_translation_field_info_alter(&$info) {
  foreach ($info as $field_type => &$field_type_info) {
    // By default no column has to be synchronized.
    $field_type_info['settings'] += array('translation_sync' => FALSE);
    // Synchronization can be enabled per instance.
    $field_type_info['instance_settings'] += array('translation_sync' => FALSE);
  }
}

/**
 * Implements hook_entity_presave().
 */
function content_translation_entity_presave(EntityInterface $entity) {
  if ($entity->isTranslatable()) {
    // @todo Avoid using request attributes once translation metadata become
    //   regular fields.
    $attributes = Drupal::request()->attributes;
    Drupal::service('content_translation.synchronizer')->synchronizeFields($entity, $entity->language()->id, $attributes->get('source_langcode'));
  }
}

/**
 * Implements hook_element_info_alter().
 */
function content_translation_element_info_alter(&$type) {
  if (isset($type['language_configuration'])) {
    $type['language_configuration']['#process'][] = 'content_translation_language_configuration_element_process';
  }
}

/**
 * Returns a widget to enable content translation per entity bundle.
 *
 * Backward compatibility layer to support entities not using the language
 * configuration form element.
 *
 * @todo Remove once all core entities have language configuration.
 *
 * @param string $entity_type
 *   The type of the entity being configured for translation.
 * @param string $bundle
 *   The bundle of the entity being configured for translation.
 * @param array $form
 *   The configuration form array.
 * @param array $form_state
 *   The configuration form state array.
 */
function content_translation_enable_widget($entity_type, $bundle, array &$form, array &$form_state) {
  $key = $form_state['content_translation']['key'];
  if (!isset($form_state['language'][$key])) {
    $form_state['language'][$key] = array();
  }
  $form_state['language'][$key] += array('entity_type' => $entity_type, 'bundle' => $bundle);
  $element = content_translation_language_configuration_element_process(array('#name' => $key), $form_state, $form);
  unset($element['content_translation']['#element_validate']);
  return $element;
}

/**
 * Process callback: Expands the language_configuration form element.
 *
 * @param array $element
 *   Form API element.
 *
 * @return
 *   Processed language configuration element.
 */
function content_translation_language_configuration_element_process(array $element, array &$form_state, array &$form) {
  if (empty($element['#content_translation_skip_alter']) && user_access('administer content translation')) {
    $form_state['content_translation']['key'] = $element['#name'];
    $context = $form_state['language'][$element['#name']];

    $element['content_translation'] = array(
      '#type' => 'checkbox',
      '#title' => t('Enable translation'),
      '#default_value' => content_translation_enabled($context['entity_type'], $context['bundle']),
      '#element_validate' => array('content_translation_language_configuration_element_validate'),
      '#prefix' => '<label>' . t('Translation') . '</label>',
    );

    $form['actions']['submit']['#submit'][] = 'content_translation_language_configuration_element_submit';
  }
  return $element;
}

/**
 * Form validation handler for element added with content_translation_language_configuration_element_process().
 *
 * Checks whether translation can be enabled: if language is set to one of the
 * special languages and language selector is not hidden, translation cannot be
 * enabled.
 *
 * @see content_translation_language_configuration_element_submit()
 */
function content_translation_language_configuration_element_validate($element, array &$form_state, array $form) {
  $key = $form_state['content_translation']['key'];
  $values = $form_state['values'][$key];
  if (language_is_locked($values['langcode']) && !$values['language_show'] && $values['content_translation']) {
    foreach (language_list(Language::STATE_LOCKED) as $language) {
      $locked_languages[] = $language->name;
    }
    // @todo Set the correct form element name as soon as the element parents
    //   are correctly set. We should be using NestedArray::getValue() but for
    //   now we cannot.
    form_set_error('', t('"Show language selector" is not compatible with translating content that has default language: %choice. Either do not hide the language selector or pick a specific language.', array('%choice' => $locked_languages[$values['langcode']])));
  }
}

/**
 * Form submission handler for element added with content_translation_language_configuration_element_process().
 *
 * Stores the content translation settings.
 *
 * @see content_translation_language_configuration_element_validate()
 */
function content_translation_language_configuration_element_submit(array $form, array &$form_state) {
  $key = $form_state['content_translation']['key'];
  $context = $form_state['language'][$key];
  $enabled = $form_state['values'][$key]['content_translation'];

  if (content_translation_enabled($context['entity_type'], $context['bundle']) != $enabled) {
    content_translation_set_config($context['entity_type'], $context['bundle'], 'enabled', $enabled);
    entity_info_cache_clear();
    menu_router_rebuild();
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for language_content_settings_form().
 */
function content_translation_form_language_content_settings_form_alter(array &$form, array &$form_state) {
  module_load_include('inc', 'content_translation', 'content_translation.admin');
  _content_translation_form_language_content_settings_form_alter($form, $form_state);
}

/**
 * Implements hook_preprocess_HOOK() for theme_language_content_settings_table().
 */
function content_translation_preprocess_language_content_settings_table(&$variables) {
  module_load_include('inc', 'content_translation', 'content_translation.admin');
  _content_translation_preprocess_language_content_settings_table($variables);
}

/**
 * Stores content translation settings.
 *
 * @param array $settings
 *   An associative array of settings keyed by entity type and bundle. At bundle
 *   level the following keys are available:
 *   - translatable: The bundle translatability status, which is a bool.
 *   - settings: An array of language configuration settings as defined by
 *     language_save_default_configuration().
 *   - fields: An associative array with field names as keys and a boolean as
 *     value, indicating field translatability.
 *   - columns: An associative array of translation synchronization settings
 *     keyed by field names.
 */
function content_translation_save_settings($settings) {
  foreach ($settings as $entity_type => $entity_settings) {
    foreach ($entity_settings as $bundle => $bundle_settings) {
      // The 'translatable' value is set only if it is possible to enable.
      if (isset($bundle_settings['translatable'])) {
        // Store whether a bundle has translation enabled or not.
        content_translation_set_config($entity_type, $bundle, 'enabled', $bundle_settings['translatable']);

        // Store whether fields have translation enabled or not.
        if (!empty($bundle_settings['columns'])) {
          foreach ($bundle_settings['columns'] as $field_name => $column_settings) {
            $field = field_info_field($field_name);
            $instance = field_info_instance($entity_type, $field_name, $bundle);
            if ($field['translatable']) {
              $instance['settings']['translation_sync'] = $column_settings;
            }
            // If the field does not have translatable enabled we need to reset
            // the sync settings to their defaults.
            else {
              unset($instance['settings']['translation_sync']);
            }
            $instance->save();
          }
        }
      }
    }
  }

  // Ensure entity and menu router information are correctly rebuilt.
  entity_info_cache_clear();
  menu_router_rebuild();
}
