<?php

use Drupal\Component\Utility\Crypt;
use Drupal\Core\Database\Query\SelectInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\entity\Plugin\Core\Entity\EntityDisplay;
use Drupal\file\Plugin\Core\Entity\File;
use Drupal\user\Plugin\Core\Entity\User;
use Drupal\user\UserInterface;
use Drupal\user\RoleInterface;
use Drupal\Core\Template\Attribute;
use Symfony\Component\HttpFoundation\RedirectResponse;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use Drupal\menu_link\Plugin\Core\Entity\MenuLink;

/**
 * @file
 * Enables the user registration and login system.
 */

/**
 * Maximum length of username text field.
 */
const USERNAME_MAX_LENGTH = 60;

/**
 * Maximum length of user e-mail text field.
 */
const EMAIL_MAX_LENGTH = 254;

/**
 * Only administrators can create user accounts.
 */
const USER_REGISTER_ADMINISTRATORS_ONLY = 'admin_only';

/**
 * Visitors can create their own accounts.
 */
const USER_REGISTER_VISITORS = 'visitors';

/**
 * Visitors can create accounts, but they don't become active without
 * administrative approval.
 */
const USER_REGISTER_VISITORS_ADMINISTRATIVE_APPROVAL = 'visitors_admin_approval';

/**
 * Implement hook_help().
 */
function user_help($path, $arg) {
  switch ($path) {
    case 'admin/help#user':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The User module allows users to register, log in, and log out. It also allows users with proper permissions to manage user roles (used to classify users) and permissions associated with those roles. For more information, see the online handbook entry for <a href="@user">User module</a>.', array('@user' => 'http://drupal.org/documentation/modules/user')) . '</p>';
      $output .= '<h3>' . t('Uses') . '</h3>';
      $output .= '<dl>';
      $output .= '<dt>' . t('Creating and managing users') . '</dt>';
      $output .= '<dd>' . t('The User module allows users with the appropriate <a href="@permissions">permissions</a> to create user accounts through the <a href="@people">People administration page</a>, where they can also assign users to one or more roles, and block or delete user accounts. If allowed, users without accounts (anonymous users) can create their own accounts on the <a href="@register">Create new account</a> page.', array('@permissions' => url('admin/people/permissions', array('fragment' => 'module-user')), '@people' => url('admin/people'), '@register' => url('user/register'))) . '</dd>';
      $output .= '<dt>' . t('User roles and permissions') . '</dt>';
      $output .= '<dd>' . t('<em>Roles</em> are used to group and classify users; each user can be assigned one or more roles. By default there are two roles: <em>anonymous user</em> (users that are not logged in) and <em>authenticated user</em> (users that are registered and logged in). Depending on choices you made when you installed Drupal, the installation process may have defined more roles, and you can create additional custom roles on the <a href="@roles">Roles page</a>. After creating roles, you can set permissions for each role on the <a href="@permissions_user">Permissions page</a>. Granting a permission allows users who have been assigned a particular role to perform an action on the site, such as viewing a particular type of content, editing or creating content, administering settings for a particular module, or using a particular function of the site (such as search).', array('@permissions_user' => url('admin/people/permissions'), '@roles' => url('admin/people/roles'))) . '</dd>';
      $output .= '<dt>' . t('Account settings') . '</dt>';
      $output .= '<dd>' . t('The <a href="@accounts">Account settings page</a> allows you to manage settings for the displayed name of the anonymous user role, personal contact forms, user registration, and account cancellation. On this page you can also manage settings for account personalization (including signatures), and adapt the text for the e-mail messages that are sent automatically during the user registration process.', array('@accounts'  => url('admin/config/people/accounts'))) . '</dd>';
      $output .= '</dl>';
      return $output;
    case 'admin/people/create':
      return '<p>' . t("This web page allows administrators to register new users. Users' e-mail addresses and usernames must be unique.") . '</p>';
    case 'admin/people/permissions':
      return '<p>' . t('Permissions let you control what users can do and see on your site. You can define a specific set of permissions for each role. (See the <a href="@role">Roles</a> page to create a role). Two important roles to consider are Authenticated Users and Administrators. Any permissions granted to the Authenticated Users role will be given to any user who can log into your site. You can make any role the Administrator role for the site, meaning this will be granted all new permissions automatically. You can do this on the <a href="@settings">User Settings</a> page. You should be careful to ensure that only trusted users are given this access and level of control of your site.', array('@role' => url('admin/people/roles'), '@settings' => url('admin/config/people/accounts'))) . '</p>';
    case 'admin/people/roles':
      $output = '<p>' . t('Roles allow you to fine tune the security and administration of Drupal. A role defines a group of users that have certain privileges as defined on the <a href="@permissions">permissions page</a>. Examples of roles include: anonymous user, authenticated user, moderator, administrator and so on. In this area you will define the names and order of the roles on your site. It is recommended to order your roles from least permissive (anonymous user) to most permissive (administrator). To delete a role choose "edit role".', array('@permissions' => url('admin/people/permissions'))) . '</p>';
      $output .= '<p>' . t('Drupal has three special user roles:') . '</p>';
      $output .= '<ul>';
      $output .= '<li>' . t("Anonymous user: this role is used for users that don't have a user account or that are not authenticated.") . '</li>';
      $output .= '<li>' . t('Authenticated user: this role is automatically granted to all logged in users.') . '</li>';
      $output .= '<li>' . t('Administrator role: this role is automatically granted all new permissions when you install a new module. Configure which role is the administrator role on the <a href="@account_settings">Account settings page</a>.', array('@account_settings' => url('admin/config/people/accounts'))) . '</li>';
      $output .= '</ul>';
      return $output;
    case 'admin/config/people/accounts/fields':
      return '<p>' . t('This form lets administrators add and edit fields for storing user data.') . '</p>';
    case 'admin/config/people/accounts/form-display':
      return '<p>' . t('This form lets administrators configure how form fields should be displayed when editing a user profile.') . '</p>';
    case 'admin/config/people/accounts/display':
      return '<p>' . t('This form lets administrators configure how fields should be displayed when rendering a user profile page.') . '</p>';
    case 'admin/people/search':
      return '<p>' . t('Enter a simple pattern ("*" may be used as a wildcard match) to search for a username or e-mail address. For example, one may search for "br" and Drupal might return "brian", "brad", and "brenda@example.com".') . '</p>';
  }
}

/**
 * Implements hook_theme().
 */
function user_theme() {
  return array(
    'user' => array(
      'render element' => 'elements',
      'file' => 'user.pages.inc',
      'template' => 'user',
    ),
    'user_permission_description' => array(
      'variables' => array('permission_item' => NULL, 'hide' => NULL),
      'file' => 'user.admin.inc',
    ),
    'user_signature' => array(
      'variables' => array('signature' => NULL),
    ),
    'username' => array(
      'variables' => array('account' => NULL, 'attributes' => array()),
    ),
  );
}

/**
 * Implements hook_page_build().
 */
function user_page_build(&$page) {
  $path = drupal_get_path('module', 'user');
  $page['#attached']['css'][$path . '/css/user.module.css'] = array('every_page' => TRUE);
}

/**
 * Implements hook_entity_bundle_info().
 */
function user_entity_bundle_info() {
  $bundles['user']['user']['label'] = t('User');
  return $bundles;
}

/**
 * Entity URI callback.
 */
function user_uri($user) {
  return array(
    'path' => 'user/' . $user->id(),
  );
}

/**
 * Entity label callback.
 *
 * This label callback has langcode for security reasons. The username is the
 * visual identifier for a user and needs to be consistent in all languages.
 *
 * @param $entity_type
 *   The entity type.
 * @param $entity
 *   The entity object.
 *
 * @return
 *   The name of the user.
 *
 * @see user_format_name()
 */
function user_label($entity_type, $entity) {
  return $entity->getUsername();
}

/**
 * Populates $entity->account for each prepared entity.
 *
 * Called by Drupal\Core\Entity\EntityRenderControllerInterface::buildContent()
 * implementations.
 *
 * @param array $entities
 *   The entities keyed by entity ID.
 */
function user_attach_accounts(array $entities) {
  $uids = array();
  foreach ($entities as $entity) {
    $uids[] = $entity->uid;
  }
  $uids = array_unique($uids);
  $accounts = user_load_multiple($uids);
  $anonymous = drupal_anonymous_user();
  foreach ($entities as $id => $entity) {
    if (isset($accounts[$entity->uid])) {
      $entities[$id]->account = $accounts[$entity->uid];
    }
    else {
      $entities[$id]->account = $anonymous;
    }
  }
}

/**
 * Returns whether this site supports the default user picture feature.
 *
 * This approach preserves compatibility with node/comment templates. Alternate
 * user picture implementations (e.g., Gravatar) should provide their own
 * add/edit/delete forms and populate the 'picture' variable during the
 * preprocess stage.
 */
function user_picture_enabled() {
  return (bool) field_info_instance('user', 'user_picture', 'user');
}

/**
 * Implements hook_field_extra_fields().
 */
function user_field_extra_fields() {
  $fields['user']['user']['form']['account'] = array(
    'label' => t('User name and password'),
    'description' => t('User module account form elements.'),
    'weight' => -10,
  );
  if (Drupal::config('user.settings')->get('signatures')) {
    $fields['user']['user']['form']['signature_settings'] = array(
      'label' => t('Signature settings'),
      'description' => t('User module form element.'),
      'weight' => 1,
    );
  }
  $fields['user']['user']['form']['language'] = array(
    'label' => t('Language settings'),
    'description' => t('User module form element.'),
    'weight' => 0,
  );
  if (Drupal::config('system.date')->get('timezone.user.configurable')) {
    $fields['user']['user']['form']['timezone'] = array(
      'label' => t('Timezone'),
      'description' => t('System module form element.'),
      'weight' => 6,
    );
  }

  $fields['user']['user']['display']['member_for'] = array(
    'label' => t('Member for'),
    'description' => t('User module \'member for\' view element.'),
    'weight' => 5,
  );

  return $fields;
}

/**
 * Loads multiple users based on certain conditions.
 *
 * This function should be used whenever you need to load more than one user
 * from the database. Users are loaded into memory and will not require
 * database access if loaded again during the same page request.
 *
 * @param array $uids
 *   (optional) An array of entity IDs. If omitted, all entities are loaded.
 * @param bool $reset
 *   A boolean indicating that the internal cache should be reset. Use this if
 *   loading a user object which has been altered during the page request.
 *
 * @return array
 *   An array of user objects, indexed by uid.
 *
 * @see entity_load_multiple()
 * @see user_load()
 * @see user_load_by_mail()
 * @see user_load_by_name()
 * @see \Drupal\Core\Entity\Query\QueryInterface
 */
function user_load_multiple(array $uids = NULL, $reset = FALSE) {
  return entity_load_multiple('user', $uids, $reset);
}

/**
 * Loads a user object.
 *
 * Drupal has a global $user object, which represents the currently-logged-in
 * user. So to avoid confusion and to avoid clobbering the global $user object,
 * it is a good idea to assign the result of this function to a different local
 * variable, generally $account. If you actually do want to act as the user you
 * are loading, it is essential to call drupal_save_session(FALSE); first.
 * See
 * @link http://drupal.org/node/218104 Safely impersonating another user @endlink
 * for more information.
 *
 * @param int $uid
 *   Integer specifying the user ID to load.
 * @param bool $reset
 *   TRUE to reset the internal cache and load from the database; FALSE
 *   (default) to load from the internal cache, if set.
 *
 * @return object
 *   A fully-loaded user object upon successful user load, or NULL if the user
 *   cannot be loaded.
 *
 * @see user_load_multiple()
 */
function user_load($uid, $reset = FALSE) {
  return entity_load('user', $uid, $reset);
}

/**
 * Fetches a user object by email address.
 *
 * @param string $mail
 *   String with the account's e-mail address.
 * @return object|bool
 *   A fully-loaded $user object upon successful user load or FALSE if user
 *   cannot be loaded.
 *
 * @see user_load_multiple()
 */
function user_load_by_mail($mail) {
  $users = entity_load_multiple_by_properties('user', array('mail' => $mail));
  return $users ? reset($users) : FALSE;
}

/**
 * Fetches a user object by account name.
 *
 * @param string $name
 *   String with the account's user name.
 * @return object|bool
 *   A fully-loaded $user object upon successful user load or FALSE if user
 *   cannot be loaded.
 *
 * @see user_load_multiple()
 */
function user_load_by_name($name) {
  $users = entity_load_multiple_by_properties('user', array('name' => $name));
  return $users ? reset($users) : FALSE;
}

/**
 * Verify the syntax of the given name.
 */
function user_validate_name($name) {
  if (!$name) {
    return t('You must enter a username.');
  }
  if (substr($name, 0, 1) == ' ') {
    return t('The username cannot begin with a space.');
  }
  if (substr($name, -1) == ' ') {
    return t('The username cannot end with a space.');
  }
  if (strpos($name, '  ') !== FALSE) {
    return t('The username cannot contain multiple spaces in a row.');
  }
  if (preg_match('/[^\x{80}-\x{F7} a-z0-9@_.\'-]/i', $name)) {
    return t('The username contains an illegal character.');
  }
  if (preg_match('/[\x{80}-\x{A0}' .         // Non-printable ISO-8859-1 + NBSP
                  '\x{AD}' .                // Soft-hyphen
                  '\x{2000}-\x{200F}' .     // Various space characters
                  '\x{2028}-\x{202F}' .     // Bidirectional text overrides
                  '\x{205F}-\x{206F}' .     // Various text hinting characters
                  '\x{FEFF}' .              // Byte order mark
                  '\x{FF01}-\x{FF60}' .     // Full-width latin
                  '\x{FFF9}-\x{FFFD}' .     // Replacement characters
                  '\x{0}-\x{1F}]/u',        // NULL byte and control characters
                  $name)) {
    return t('The username contains an illegal character.');
  }
  if (drupal_strlen($name) > USERNAME_MAX_LENGTH) {
    return t('The username %name is too long: it must be %max characters or less.', array('%name' => $name, '%max' => USERNAME_MAX_LENGTH));
  }
}

/**
 * Generate a random alphanumeric password.
 */
function user_password($length = 10) {
  // This variable contains the list of allowable characters for the
  // password. Note that the number 0 and the letter 'O' have been
  // removed to avoid confusion between the two. The same is true
  // of 'I', 1, and 'l'.
  $allowable_characters = 'abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ23456789';

  // Zero-based count of characters in the allowable list:
  $len = strlen($allowable_characters) - 1;

  // Declare the password as a blank string.
  $pass = '';

  // Loop the number of times specified by $length.
  for ($i = 0; $i < $length; $i++) {

    // Each iteration, pick a random character from the
    // allowable string and append it to the password:
    $pass .= $allowable_characters[mt_rand(0, $len)];
  }

  return $pass;
}

/**
 * Determine the permissions for one or more roles.
 *
 * @param array $roles
 *   An array of role IDs.
 *
 * @return array
 *   An array indexed by role ID. Each value is an array of permission strings
 *   for the given role.
 */
function user_role_permissions(array $roles) {
  if (defined('MAINTENANCE_MODE') && MAINTENANCE_MODE == 'update') {
    return _user_role_permissions_update($roles);
  }
  $entities = entity_load_multiple('user_role', $roles);
  $role_permissions = array();
  foreach ($roles as $rid) {
    $role_permissions[$rid] = isset($entities[$rid]) ? $entities[$rid]->getPermissions() : array();
  }
  return $role_permissions;
}

/**
 * Determine the permissions for one or more roles during update.
 *
 * A separate version is needed because during update the entity system can't
 * be used and in non-update situations the entity system is preferred because
 * of the hook system.
 *
 * @param array $roles
 *   An array of role IDs.
 *
 * @return array
 *   An array indexed by role ID. Each value is an array of permission strings
 *   for the given role.
 */
function _user_role_permissions_update($roles) {
  $role_permissions = array();
  foreach ($roles as $rid) {
    $role_permissions[$rid] = Drupal::config("user.role.$rid")->get('permissions') ?: array();
  }
  return $role_permissions;
}

/**
 * Determine whether the user has a given privilege.
 *
 * @param $string
 *   The permission, such as "administer nodes", being checked for.
 * @param \Drupal\Core\Session\AccountInterface $account
 *   (optional) The account to check, if not given use currently logged in user.
 *
 * @return bool
 *   Boolean TRUE if the current user has the requested permission.
 *
 * @deprecated as of Drupal 8.0. Use
 *   \Drupal\Core\Session\AccountInterface::hasPermission()
 */
function user_access($string, AccountInterface $account = NULL) {
  global $user;

  if (!isset($account)) {
    // In the installer request session is not set, so we have to fall back
    // to the global $user. In all other cases the session key is preferred.
    $account = Drupal::request()->attributes->get('_account') ?: $user;
  }

  return $account->hasPermission($string);
}

/**
 * Checks for usernames blocked by user administration.
 *
 * @param $name
 *   A string containing a name of the user.
 *
 * @return
 *   Object with property 'name' (the user name), if the user is blocked;
 *   FALSE if the user is not blocked.
 */
function user_is_blocked($name) {
  return db_select('users')
    ->fields('users', array('name'))
    ->condition('name', db_like($name), 'LIKE')
    ->condition('status', 0)
    ->execute()->fetchObject();
}

/**
 * Implements hook_permission().
 */
function user_permission() {
  return array(
    'administer permissions' =>  array(
      'title' => t('Administer permissions'),
      'restrict access' => TRUE,
    ),
    'administer users' => array(
      'title' => t('Administer users'),
      'restrict access' => TRUE,
    ),
    'access user profiles' => array(
      'title' => t('View user profiles'),
    ),
    'change own username' => array(
      'title' => t('Change own username'),
    ),
    'cancel account' => array(
      'title' => t('Cancel own user account'),
      'description' => t('Note: content may be kept, unpublished, deleted or transferred to the %anonymous-name user depending on the configured <a href="@user-settings-url">user settings</a>.', array('%anonymous-name' => Drupal::config('user.settings')->get('anonymous'), '@user-settings-url' => url('admin/config/people/accounts'))),
    ),
    'select account cancellation method' => array(
      'title' => t('Select method for cancelling own account'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_search_info().
 */
function user_search_info() {
  return array(
    'title' => 'Users',
  );
}

/**
 * Implements hook_search_access().
 */
function user_search_access() {
  return user_access('access user profiles');
}

/**
 * Implements hook_search_execute().
 */
function user_search_execute($keys = NULL, $conditions = NULL) {
  // Replace wildcards with MySQL/PostgreSQL wildcards.
  $keys = preg_replace('!\*+!', '%', $keys);
  $query = db_select('users')
    ->extend('Drupal\Core\Database\Query\PagerSelectExtender');
  $query->fields('users', array('uid'));
  if (user_access('administer users')) {
    // Administrators can also search in the otherwise private email field, and
    // they don't need to be restricted to only active users.
    $query->fields('users', array('mail'));
    $query->condition(db_or()->
      condition('name', '%' . db_like($keys) . '%', 'LIKE')->
      condition('mail', '%' . db_like($keys) . '%', 'LIKE'));
  }
  else {
    // Regular users can only search via usernames, and we do not show them
    // blocked accounts.
    $query->condition('name', '%' . db_like($keys) . '%', 'LIKE')
      ->condition('status', 1);
  }
  $uids = $query
    ->limit(15)
    ->execute()
    ->fetchCol();
  $accounts = user_load_multiple($uids);

  $results = array();
  foreach ($accounts as $account) {
    $result = array(
      'title' => user_format_name($account),
      'link' => url('user/' . $account->id(), array('absolute' => TRUE)),
    );
    if (user_access('administer users')) {
      $result['title'] .= ' (' . $account->getEmail() . ')';
    }
    $results[] = $result;
  }

  return $results;
}

/**
 * Implements hook_user_view().
 */
function user_user_view(UserInterface $account, EntityDisplay $display) {
  if ($display->getComponent('member_for')) {
    $account->content['member_for'] = array(
      '#type' => 'item',
      '#title' => t('Member for'),
      '#markup' => format_interval(REQUEST_TIME - $account->getCreatedTime()),
    );
  }
}

/**
 * Sets the value of the user register and profile forms' langcode element.
 */
function _user_language_selector_langcode_value($element, $input, &$form_state) {
  // Only add to the description if the form element have a description.
  if (isset($form_state['complete_form']['language']['preferred_langcode']['#description'])) {
    $form_state['complete_form']['language']['preferred_langcode']['#description'] .= ' ' . t("This is also assumed to be the primary language of this account's profile information.");
  }
  return $form_state['values']['preferred_langcode'];
}

/**
 * Form validation handler for the current password on the user account form.
 *
 * @see AccountFormController::form()
 */
function user_validate_current_pass(&$form, &$form_state) {
  $account = $form_state['user'];
  foreach ($form_state['values']['current_pass_required_values'] as $key => $name) {
    // This validation only works for required textfields (like mail) or
    // form values like password_confirm that have their own validation
    // that prevent them from being empty if they are changed.
    $current_value = $account->getPropertyDefinition($key) ? $account->get($key)->value : $account->$key;
    if ((strlen(trim($form_state['values'][$key])) > 0) && ($form_state['values'][$key] != $current_value)) {
      $current_pass_failed = empty($form_state['values']['current_pass']) || !drupal_container()->get('password')->check($form_state['values']['current_pass'], $account);
      if ($current_pass_failed) {
        form_set_error('current_pass', t("Your current password is missing or incorrect; it's required to change the %name.", array('%name' => $name)));
        form_set_error($key);
      }
      // We only need to check the password once.
      break;
    }
  }
}

/**
 * Implements hook_preprocess_HOOK() for block.html.twig.
 */
function user_preprocess_block(&$variables) {
  if ($variables['configuration']['module'] == 'user') {
    switch ($variables['elements']['#plugin_id']) {
      case 'user_login_block':
        $variables['attributes']['role'] = 'form';
        break;
      case 'user_new_block':
        $variables['attributes']['role'] = 'complementary';
        break;
      case 'user_online_block':
        $variables['attributes']['role'] = 'complementary';
        break;
    }
  }
}

/**
 * Format a username.
 *
 * @param \Drupal\Core\Session\Interface $account
 *   The account object for the user whose name is to be formatted.
 *
 * @return
 *   An unsanitized string with the username to display. The code receiving
 *   this result must ensure that check_plain() is called on it before it is
 *   printed to the page.
 *
 * @deprecated Use \Drupal\Core\Session\Interface::getUsername() instead.
 */
function user_format_name(AccountInterface $account) {
  return $account->getUsername();
}

/**
 * Implements hook_template_preprocess_default_variables_alter().
 *
 * @see user_user_login()
 * @see user_user_logout()
 */
function user_template_preprocess_default_variables_alter(&$variables) {
  global $user;

  // If this function is called from the installer after Drupal has been
  // installed then $user will not be set.
  if (!is_object($user)) {
    return;
  }

  $variables['user'] = clone $user;
  // Remove password and session IDs, since themes should not need nor see them.
  unset($variables['user']->pass, $variables['user']->sid, $variables['user']->ssid);

  $variables['is_admin'] = user_access('access administration pages');
  $variables['logged_in'] = $user->isAuthenticated();
}

/**
 * Preprocesses variables for theme_username().
 *
 * Modules that make any changes to variables like 'name' or 'extra' must ensure
 * that the final string is safe to include directly in the output by using
 * check_plain() or filter_xss().
 */
function template_preprocess_username(&$variables) {
  $account = $variables['account'] ?: drupal_anonymous_user();

  $variables['extra'] = '';
  $variables['uid'] = $account->id();
  if (empty($variables['uid'])) {
    if (theme_get_setting('features.comment_user_verification')) {
      $variables['extra'] = ' (' . t('not verified') . ')';
    }
  }

  // Set the name to a formatted name that is safe for printing and
  // that won't break tables by being too long. Keep an unshortened,
  // unsanitized version, in case other preprocess functions want to implement
  // their own shortening logic or add markup. If they do so, they must ensure
  // that $variables['name'] is safe for printing.
  $name = $variables['name_raw'] = $account->getUsername();
  if (drupal_strlen($name) > 20) {
    $name = drupal_substr($name, 0, 15) . '...';
  }
  $variables['name'] = check_plain($name);
  $variables['profile_access'] = user_access('access user profiles');

  // Populate link path and attributes if appropriate.
  if ($variables['uid'] && $variables['profile_access']) {
    // We are linking to a local user.
    $variables['link_options']['attributes']['title'] = t('View user profile.');
    $variables['link_path'] = 'user/' . $variables['uid'];
  }
  elseif (!empty($account->homepage)) {
    // Like the 'class' attribute, the 'rel' attribute can hold a
    // space-separated set of values, so initialize it as an array to make it
    // easier for other preprocess functions to append to it.
    $variables['link_options']['attributes']['rel'] = 'nofollow';
    $variables['link_path'] = $account->homepage;
    $variables['homepage'] = $account->homepage;
  }
  // We do not want the l() function to check_plain() a second time.
  $variables['link_options']['html'] = TRUE;
  // Set a default class.
  $variables['link_options']['attributes']['class'] = array('username');
}

/**
 * Returns HTML for a username, potentially linked to the user's page.
 *
 * @param $variables
 *   An associative array containing:
 *   - account: The user object to format.
 *   - name: The user's name, sanitized.
 *   - extra: Additional text to append to the user's name, sanitized.
 *   - link_path: The path or URL of the user's profile page, home page, or
 *     other desired page to link to for more information about the user.
 *   - link_options: An array of options to pass to the l() function's $options
 *     parameter if linking the user's name to the user's page.
 *   - attributes: An array of attributes to instantiate the
 *     Drupal\Core\Template\Attribute class if not linking to the user's page.
 *
 * @see template_preprocess_username()
 */
function theme_username($variables) {
  if (isset($variables['link_path'])) {
    // We have a link path, so we should generate a link using l().
    // Additional classes may be added as array elements like
    // $variables['link_options']['attributes']['class'][] = 'myclass';
    $output = l($variables['name'] . $variables['extra'], $variables['link_path'], $variables['link_options']);
  }
  else {
    // Modules may have added important attributes so they must be included
    // in the output. Additional classes may be added as array elements like
    // $variables['attributes']['class'][] = 'myclass';
    $output = '<span' . new Attribute($variables['attributes']) . '>' . $variables['name'] . $variables['extra'] . '</span>';
  }
  return $output;
}

/**
 * Determines if the current user is anonymous.
 *
 * @return bool
 *   TRUE if the user is anonymous, FALSE if the user is authenticated.
 */
function user_is_anonymous() {
  // Menu administrators can see items for anonymous when administering.
  return $GLOBALS['user']->isAnonymous() || !empty($GLOBALS['menu_admin']);
}

/**
 * Determines if the current user is logged in.
 *
 * @return bool
 *   TRUE if the user is logged in, FALSE if the user is anonymous.
 *
 * @deprecated Use \Drupal\Core\Session\UserSession::isAuthenticated().
 */
function user_is_logged_in() {
  return $GLOBALS['user']->isAuthenticated();
}

/**
 * Determines if the current user has access to the user registration page.
 *
 * @return bool
 *   TRUE if the user is not already logged in and can register for an account.
 */
function user_register_access() {
  return user_is_anonymous() && (Drupal::config('user.settings')->get('register') != USER_REGISTER_ADMINISTRATORS_ONLY);
}

/**
 * Implements hook_menu().
 */
function user_menu() {
  // Registration and login pages.
  $items['user'] = array(
    'title' => 'User account',
    'title callback' => 'user_menu_title',
    'weight' => -10,
    'route_name' => 'user_page',
    'menu_name' => 'account',
  );

  $items['user/login'] = array(
    'title' => 'Log in',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  // Other authentication methods may add pages below user/login/.
  $items['user/login/default'] = array(
    'title' => 'Username and password',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['user/register'] = array(
    'title' => 'Create new account',
    'type' => MENU_LOCAL_TASK,
    'route_name' => 'user_register',
  );

  $items['user/password'] = array(
    'title' => 'Request new password',
    'route_name' => 'user_pass',
    'type' => MENU_LOCAL_TASK,
  );
  $items['user/reset/%/%/%'] = array(
    'title' => 'Reset password',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('user_pass_reset', 2, 3, 4),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
    'file' => 'user.pages.inc',
  );

  $items['user/logout'] = array(
    'title' => 'Log out',
    'route_name' => 'user_logout',
    'weight' => 10,
    'menu_name' => 'account',
  );

  // User listing pages.
  $items['admin/people'] = array(
    'title' => 'People',
    'description' => 'Manage user accounts, roles, and permissions.',
    'page callback' => 'user_admin_account',
    'access arguments' => array('administer users'),
    'position' => 'left',
    'weight' => -4,
    'file' => 'user.admin.inc',
  );
  // Permissions and role forms.
  $items['admin/people/permissions'] = array(
    'title' => 'Permissions',
    'description' => 'Determine access to features by selecting permissions for roles.',
    'route_name' => 'user_admin_permissions',
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/people/roles'] = array(
    'title' => 'Roles',
    'description' => 'List, edit, or add user roles.',
    'route_name' => 'user_role_list',
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/people/roles/add'] = array(
    'title' => 'Add role',
    'route_name' => 'user_role_add',
    'type' => MENU_LOCAL_ACTION,
  );

  $items['admin/people/roles/manage/%user_role'] = array(
    'title' => 'Edit role',
    'route_name' => 'user_role_edit',
  );
  $items['admin/people/roles/manage/%user_role/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/people/roles/manage/%user_role/delete'] = array(
    'title' => 'Delete role',
    'route_name' => 'user_role_delete',
    'weight' => 10,
    'context' => MENU_CONTEXT_INLINE,
  );

  $items['admin/people/create'] = array(
    'title' => 'Add user',
    'route_name' => 'user_admin_create',
    'type' => MENU_LOCAL_ACTION,
  );
  $items['admin/people/cancel'] = array(
    'title' => 'Cancel user',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('user_multiple_cancel_confirm'),
    'access arguments' => array('administer users'),
    'file' => 'user.admin.inc',
    'type' => MENU_CALLBACK,
  );

  // Administration pages.
  $items['admin/config/people'] = array(
   'title' => 'People',
   'description' => 'Configure user accounts.',
   'position' => 'left',
   'weight' => -20,
   'page callback' => 'system_admin_menu_block_page',
   'access arguments' => array('access administration pages'),
   'file' => 'system.admin.inc',
   'file path' => drupal_get_path('module', 'system'),
  );
  $items['admin/config/people/accounts'] = array(
    'title' => 'Account settings',
    'description' => 'Configure default behavior of users, including registration requirements, e-mails, and fields.',
    'weight' => -10,
    'route_name' => 'user_account_settings',
  );
  $items['admin/config/people/accounts/settings'] = array(
    'title' => 'Settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['user/%user'] = array(
    'title' => 'My account',
    'title callback' => 'user_page_title',
    'title arguments' => array(1),
    'page callback' => 'user_view_page',
    'page arguments' => array(1),
    'access callback' => 'entity_page_access',
    'access arguments' => array(1),
  );
  $items['user/%user/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['user/%user/cancel'] = array(
    'title' => 'Cancel account',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('user_cancel_confirm_form', 1),
    'access callback' => 'entity_page_access',
    'access arguments' => array(1, 'delete'),
    'file' => 'user.pages.inc',
  );
  $items['user/%user/cancel/confirm/%/%'] = array(
    'title' => 'Confirm account cancellation',
    'page callback' => 'user_cancel_confirm',
    'page arguments' => array(1, 4, 5),
    'access callback' => 'entity_page_access',
    'access arguments' => array(1, 'delete'),
    'file' => 'user.pages.inc',
  );
  $items['user/%user/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'entity_get_form',
    'page arguments' => array(1),
    'access callback' => 'entity_page_access',
    'access arguments' => array(1, 'update'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'user.pages.inc',
  );
  return $items;
}

/**
 * Implements hook_menu_link_presave().
 */
function user_menu_link_presave(MenuLink $menu_link) {
  // The path 'user' must be accessible for anonymous users, but only visible
  // for authenticated users. Authenticated users should see "My account", but
  // anonymous users should not see it at all. Therefore, invoke
  // user_menu_link_load() to conditionally hide the link.
  if ($menu_link->link_path == 'user' && $menu_link->module == 'system') {
    $menu_link->options['alter'] = TRUE;
  }

  // Force the Logout link to appear on the top-level of 'account' menu by
  // default (i.e., unless it has been customized).
  if ($menu_link->link_path == 'user/logout' && $menu_link->module == 'system' && empty($menu_link->customized)) {
    $menu_link->plid = 0;
  }
}

/**
 * Implements hook_menu_breadcrumb_alter().
 */
function user_menu_breadcrumb_alter(&$active_trail, $item) {
  // Remove "My account" from the breadcrumb when $item is descendant-or-self
  // of system path user/%.
  if (isset($active_trail[1]['module']) && $active_trail[1]['module'] == 'system' && $active_trail[1]['link_path'] == 'user' && strpos($item['path'], 'user/%') === 0) {
    array_splice($active_trail, 1, 1);
  }
}

/**
 * Implements hook_menu_link_load().
 */
function user_menu_link_load($menu_links) {
  // Hide the "User account" link for anonymous users.
  foreach ($menu_links as $link) {
    if ($link['link_path'] == 'user' && $link['module'] == 'system' && !$GLOBALS['user']->id()) {
      $link['hidden'] = 1;
    }
  }
}

/**
 * Implements hook_admin_paths().
 */
function user_admin_paths() {
  $paths = array(
    'user/*/cancel' => TRUE,
    'user/*/edit' => TRUE,
    'user/*/edit/*' => TRUE,
    'user/*/translations' => TRUE,
    'user/*/translations/*' => TRUE,
  );
  return $paths;
}

/**
 * Returns $arg or the user ID of the current user if $arg is '%' or empty.
 *
 * Deprecated. Use %user_uid_optional instead.
 *
 * @todo D8: Remove.
 */
function user_uid_only_optional_to_arg($arg) {
  return user_uid_optional_to_arg($arg);
}

/**
 * Load either a specified or the current user account.
 *
 * @param $uid
 *   An optional user ID of the user to load. If not provided, the current
 *   user's ID will be used.
 * @return
 *   A fully-loaded $user object upon successful user load, NULL if user
 *   cannot be loaded.
 *
 * @see user_load()
 * @todo rethink the naming of this in Drupal 8.
 */
function user_uid_optional_load($uid = NULL) {
  if (!isset($uid)) {
    $uid = $GLOBALS['user']->id();
  }
  return user_load($uid);
}

/**
 * Returns $arg or the user ID of the current user if $arg is '%' or empty.
 *
 * @todo rethink the naming of this in Drupal 8.
 */
function user_uid_optional_to_arg($arg) {
  // Give back the current user uid when called from eg. tracker, aka.
  // with an empty arg. Also use the current user uid when called from
  // the menu with a % for the current account link.
  return empty($arg) || $arg == '%' ? $GLOBALS['user']->id() : $arg;
}

/**
 * Menu item title callback for the 'user' path.
 *
 * Anonymous users should see a title based on the requested page, but
 * authenticated users are expected to see "My account".
 */
function user_menu_title() {
  if ($GLOBALS['user']->isAnonymous()) {
    switch (current_path()) {
      case 'user' :
      case 'user/login' :
        return t('Log in');
      case 'user/register' :
        return t('Create new account');
      case 'user/password' :
        return t('Request new password');
      default :
        return t('User account');
    }
  }
  else {
    return t('My account');
  }
}

/**
 * Menu item title callback - use the user name.
 */
function user_page_title(UserInterface $account = NULL) {
  return $account ? $account->getUsername() : '';
}

/**
 * Try to validate the user's login credentials locally.
 *
 * @param $name
 *   User name to authenticate.
 * @param $password
 *   A plain-text password, such as trimmed text from form values.
 * @return
 *   The user's uid on success, or FALSE on failure to authenticate.
 */
function user_authenticate($name, $password) {
  $uid = FALSE;
  if (!empty($name) && !empty($password)) {
    $account = user_load_by_name($name);
    if ($account) {
      $password_hasher = drupal_container()->get('password');
      if ($password_hasher->check($password, $account)) {
        // Successful authentication.
        $uid = $account->id();

        // Update user to new password scheme if needed.
        if ($password_hasher->userNeedsNewHash($account)) {
          $account->setPassword($password);
          $account->save();
        }
      }
    }
  }
  return $uid;
}

/**
 * Finalizes the login process and logs in a user.
 *
 * The function logs in the user, records a watchdog message about the new
 * session, saves the login timestamp, calls hook_user_login(), and generates a
 * new session.
 *
 * The global $user object is replaced with the passed in account.
 *
 * @param \Drupal\user\UserInterface $account
 *   The account to log in.
 *
 * @see hook_user_login()
 */
function user_login_finalize(UserInterface $account) {
  global $user;
  $user = $account;
  watchdog('user', 'Session opened for %name.', array('%name' => $user->getUsername()));
  // Update the user table timestamp noting user has logged in.
  // This is also used to invalidate one-time login links.
  $account->setLastLoginTime(REQUEST_TIME);
  db_update('users')
    ->fields(array('login' => $user->getLastLoginTime()))
    ->condition('uid', $user->id())
    ->execute();

  // Regenerate the session ID to prevent against session fixation attacks.
  // This is called before hook_user in case one of those functions fails
  // or incorrectly does a redirect which would leave the old session in place.
  drupal_session_regenerate();

  Drupal::moduleHandler()->invokeAll('user_login', array($user));
}

/**
 * Implements hook_user_login().
 */
function user_user_login($account) {
  // Reset static cache of default variables in template_preprocess() to reflect
  // the new user.
  drupal_static_reset('template_preprocess');
}

/**
 * Implements hook_user_logout().
 */
function user_user_logout($account) {
  // Reset static cache of default variables in template_preprocess() to reflect
  // the new user.
  drupal_static_reset('template_preprocess');
}

/**
 * Generates a unique URL for a user to login and reset their password.
 *
 * @param object $account
 *   An object containing the user account, which must contain at least the
 *   following properties:
 *   - uid: The user ID number.
 *   - login: The UNIX timestamp of the user's last login.
 * @param array $options
 *   (optional) A keyed array of settings. Supported options are:
 *   - langcode: A language code to be used when generating locale-sensitive
 *    URLs. If langcode is NULL the users preferred language is used.
 *
 * @return
 *   A unique URL that provides a one-time log in for the user, from which
 *   they can change their password.
 */
function user_pass_reset_url($account, $options = array()) {
  $timestamp = REQUEST_TIME;
  $langcode = isset($options['langcode']) ? $options['langcode'] : $account->getPreferredLangcode();
  $url_options = array('absolute' => TRUE, 'language' => language_load($langcode));
  return url("user/reset/" . $account->id() . "/$timestamp/" . user_pass_rehash($account->getPassword(), $timestamp, $account->getLastLoginTime()), $url_options);
}

/**
 * Generates a URL to confirm an account cancellation request.
 *
 * @param object $account
 *   The user account object, which must contain at least the following
 *   properties:
 *   - uid: The user ID number.
 *   - pass: The hashed user password string.
 *   - login: The UNIX timestamp of the user's last login.
 * @param array $options
 *   (optional) A keyed array of settings. Supported options are:
 *   - langcode: A language code to be used when generating locale-sensitive
  *    URLs. If langcode is NULL the users preferred language is used.
 *
 * @return
 *   A unique URL that may be used to confirm the cancellation of the user
 *   account.
 *
 * @see user_mail_tokens()
 * @see user_cancel_confirm()
 */
function user_cancel_url($account, $options = array()) {
  $timestamp = REQUEST_TIME;
  $langcode = isset($options['langcode']) ? $options['langcode'] : $account->getPreferredLangcode();
  $url_options = array('absolute' => TRUE, 'language' => language_load($langcode));
  return url("user/" . $account->id() . "/cancel/confirm/$timestamp/" . user_pass_rehash($account->getPassword(), $timestamp, $account->getLastLoginTime()), $url_options);
}

/**
 * Creates a unique hash value for use in time-dependent per-user URLs.
 *
 * This hash is normally used to build a unique and secure URL that is sent to
 * the user by email for purposes such as resetting the user's password. In
 * order to validate the URL, the same hash can be generated again, from the
 * same information, and compared to the hash value from the URL. The URL
 * normally contains both the time stamp and the numeric user ID. The login
 * timestamp and hashed password are retrieved from the database as necessary.
 * For a usage example, see user_cancel_url() and user_cancel_confirm().
 *
 * @param string $password
 *   The hashed user account password value.
 * @param int $timestamp
 *   A UNIX timestamp, typically REQUEST_TIME.
 * @param int $login
 *   The UNIX timestamp of the user's last login.
 *
 * @return
 *   A string that is safe for use in URLs and SQL statements.
 */
function user_pass_rehash($password, $timestamp, $login) {
  return Crypt::hmacBase64($timestamp . $login, drupal_get_hash_salt() . $password);
}

/**
 * Cancel a user account.
 *
 * Since the user cancellation process needs to be run in a batch, either
 * Form API will invoke it, or batch_process() needs to be invoked after calling
 * this function and should define the path to redirect to.
 *
 * @param $edit
 *   An array of submitted form values.
 * @param $uid
 *   The user ID of the user account to cancel.
 * @param $method
 *   The account cancellation method to use.
 *
 * @see _user_cancel()
 */
function user_cancel($edit, $uid, $method) {
  global $user;

  $account = user_load($uid);

  if (!$account) {
    drupal_set_message(t('The user account %id does not exist.', array('%id' => $uid)), 'error');
    watchdog('user', 'Attempted to cancel non-existing user account: %id.', array('%id' => $uid), WATCHDOG_ERROR);
    return;
  }

  // Initialize batch (to set title).
  $batch = array(
    'title' => t('Cancelling account'),
    'operations' => array(),
  );
  batch_set($batch);

  // When the 'user_cancel_delete' method is used, user_delete() is called,
  // which invokes hook_user_predelete() and hook_user_delete(). Modules
  // should use those hooks to respond to the account deletion.
  if ($method != 'user_cancel_delete') {
    // Allow modules to add further sets to this batch.
    Drupal::moduleHandler()->invokeAll('user_cancel', array($edit, $account, $method));
  }

  // Finish the batch and actually cancel the account.
  $batch = array(
    'title' => t('Cancelling user account'),
    'operations' => array(
      array('_user_cancel', array($edit, $account, $method)),
    ),
  );

  // After cancelling account, ensure that user is logged out.
  if ($account->id() == $user->id()) {
    // Batch API stores data in the session, so use the finished operation to
    // manipulate the current user's session id.
    $batch['finished'] = '_user_cancel_session_regenerate';
  }

  batch_set($batch);

  // Batch processing is either handled via Form API or has to be invoked
  // manually.
}

/**
 * Last batch processing step for cancelling a user account.
 *
 * Since batch and session API require a valid user account, the actual
 * cancellation of a user account needs to happen last.
 *
 * @see user_cancel()
 */
function _user_cancel($edit, $account, $method) {
  global $user;

  switch ($method) {
    case 'user_cancel_block':
    case 'user_cancel_block_unpublish':
    default:
      // Send account blocked notification if option was checked.
      if (!empty($edit['user_cancel_notify'])) {
        _user_mail_notify('status_blocked', $account);
      }
      $account->block();
      $account->save();
      drupal_set_message(t('%name has been disabled.', array('%name' => $account->getUsername())));
      watchdog('user', 'Blocked user: %name %email.', array('%name' => $account->getUsername(), '%email' => '<' . $account->getEmail() . '>'), WATCHDOG_NOTICE);
      break;

    case 'user_cancel_reassign':
    case 'user_cancel_delete':
      // Send account canceled notification if option was checked.
      if (!empty($edit['user_cancel_notify'])) {
        _user_mail_notify('status_canceled', $account);
      }
      $account->delete();
      drupal_set_message(t('%name has been deleted.', array('%name' => $account->getUsername())));
      watchdog('user', 'Deleted user: %name %email.', array('%name' => $account->getUsername(), '%email' => '<' . $account->getEmail() . '>'), WATCHDOG_NOTICE);
      break;
  }

  // After cancelling account, ensure that user is logged out. We can't destroy
  // their session though, as we might have information in it, and we can't
  // regenerate it because batch API uses the session ID, we will regenerate it
  // in _user_cancel_session_regenerate().
  if ($account->id() == $user->id()) {
    $user = drupal_anonymous_user();
  }

  // Clear the cache for anonymous users.
  cache_invalidate_tags(array('content' => TRUE));
}

/**
 * Finished batch processing callback for cancelling a user account.
 *
 * @see user_cancel()
 */
function _user_cancel_session_regenerate() {
  // Regenerate the users session instead of calling session_destroy() as we
  // want to preserve any messages that might have been set.
  drupal_session_regenerate();
}

/**
 * Delete a user.
 *
 * @param $uid
 *   A user ID.
 */
function user_delete($uid) {
  user_delete_multiple(array($uid));
}

/**
 * Delete multiple user accounts.
 *
 * @param $uids
 *   An array of user IDs.
 *
 * @see hook_user_predelete()
 * @see hook_user_delete()
 */
function user_delete_multiple(array $uids) {
  entity_delete_multiple('user', $uids);
}

/**
 * Page callback wrapper for user_view().
 */
function user_view_page($account) {
  if (is_object($account)) {
    return user_view($account);
  }
  // An administrator may try to view a non-existent account,
  // so we give them a 404 (versus a 403 for non-admins).
  throw new NotFoundHttpException();
}

/**
 * Generate an array for rendering the given user.
 *
 * When viewing a user profile, the $page array contains:
 *
 * - $page['content']['member_for']:
 *   Contains the default "Member for" profile data for a user.
 * - $page['content']['#user']:
 *   The user account of the profile being viewed.
 *
 * To theme user profiles, copy modules/user/user.tpl.php
 * to your theme directory, and edit it as instructed in that file's comments.
 *
 * @param $account
 *   A user object.
 * @param $view_mode
 *   View mode, e.g. 'full'.
 * @param $langcode
 *   (optional) A language code to use for rendering. Defaults to the global
 *   content language of the current request.
 *
 * @return
 *   An array as expected by drupal_render().
 */
function user_view($account, $view_mode = 'full', $langcode = NULL) {
  return entity_view($account, $view_mode, $langcode);
}

/**
 * Constructs a drupal_render() style array from an array of loaded users.
 *
 * @param $accounts
 *   An array of user accounts as returned by user_load_multiple().
 * @param $view_mode
 *   (optional) View mode, e.g., 'full', 'teaser'... Defaults to 'teaser.'
 * @param $langcode
 *   (optional) A language code to use for rendering. Defaults to the global
 *   content language of the current request.
 *
 * @return
 *   An array in the format expected by drupal_render().
 */
function user_view_multiple($accounts, $view_mode = 'full', $langcode = NULL) {
  return entity_view($accounts, $view_mode, $langcode);
}

/**
 * Implements hook_mail().
 */
function user_mail($key, &$message, $params) {
  $token_service = Drupal::token();
  $langcode = $message['langcode'];
  $variables = array('user' => $params['account']);

  // Get configuration objects customized for the user specified in $params as
  // this user is not necessarily the same as the one triggering the mail. This
  // allows the configuration objects to be localized for the user's language if
  // the locale module is enabled.
  $user_config_context = config_context_enter('Drupal\user\UserConfigContext');
  $user_config_context->setAccount($params['account']);
  $mail_config = Drupal::config('user.mail');

   // We do not sanitize the token replacement, since the output of this
   // replacement is intended for an e-mail message, not a web browser.
  $token_options = array('langcode' => $langcode, 'callback' => 'user_mail_tokens', 'sanitize' => FALSE, 'clear' => TRUE);
  $message['subject'] .= $token_service->replace($mail_config->get($key . '.subject'), $variables, $token_options);
  $message['body'][] = $token_service->replace($mail_config->get($key . '.body'), $variables, $token_options);

  // Return the previous config context.
  config_context_leave();
}

/**
 * Token callback to add unsafe tokens for user mails.
 *
 * This function is used by \Drupal\Core\Utility\Token::replace() to set up
 * some additional tokens that can be used in email messages generated by
 * user_mail().
 *
 * @param $replacements
 *   An associative array variable containing mappings from token names to
 *   values (for use with strtr()).
 * @param $data
 *   An associative array of token replacement values. If the 'user' element
 *   exists, it must contain a user account object with the following
 *   properties:
 *   - login: The UNIX timestamp of the user's last login.
 *   - pass: The hashed account login password.
 * @param $options
 *   Unused parameter required by \Drupal\Core\Utility\Token::replace().
 */
function user_mail_tokens(&$replacements, $data, $options) {
  if (isset($data['user'])) {
    $replacements['[user:one-time-login-url]'] = user_pass_reset_url($data['user'], $options);
    $replacements['[user:cancel-url]'] = user_cancel_url($data['user'], $options);
  }
}

/*** Administrative features ***********************************************/

/**
 * Retrieve an array of roles matching specified conditions.
 *
 * @param $membersonly
 *   Set this to TRUE to exclude the 'anonymous' role.
 * @param $permission
 *   A string containing a permission. If set, only roles containing that
 *   permission are returned.
 *
 * @return
 *   An associative array with the role id as the key and the role name as
 *   value.
 */
function user_role_names($membersonly = FALSE, $permission = NULL) {
  return array_map(function ($item) {
    return $item->label();
  }, user_roles($membersonly, $permission));
}

/**
 * Implements hook_user_role_insert().
 */
function user_user_role_insert(RoleInterface $role) {
  // Ignore the authenticated and anonymous roles.
  if (in_array($role->id(), array(DRUPAL_AUTHENTICATED_RID, DRUPAL_ANONYMOUS_RID))) {
    return;
  }

  $action = entity_create('action', array(
    'id' => 'user_add_role_action.' . $role->id(),
    'type' => 'user',
    'label' => t('Add the @label role to the selected users', array('@label' => $role->label())),
    'configuration' => array(
      'rid' => $role->id(),
    ),
    'plugin' => 'user_add_role_action',
  ));
  $action->save();
  $action = entity_create('action', array(
    'id' => 'user_remove_role_action.' . $role->id(),
    'type' => 'user',
    'label' => t('Remove the @label role from the selected users', array('@label' => $role->label())),
    'configuration' => array(
      'rid' => $role->id(),
    ),
    'plugin' => 'user_remove_role_action',
  ));
  $action->save();
}

/**
 * Implements hook_user_role_delete().
 */
function user_user_role_delete(RoleInterface $role) {
  // Ignore the authenticated and anonymous roles.
  if (in_array($role->id(), array(DRUPAL_AUTHENTICATED_RID, DRUPAL_ANONYMOUS_RID))) {
    return;
  }

  $actions = entity_load_multiple('action', array(
    'user_add_role_action.' . $role->id(),
    'user_remove_role_action.' . $role->id(),
  ));
  foreach ($actions as $action) {
    $action->delete();
  }
}

/**
 * Retrieve an array of roles matching specified conditions.
 *
 * @param $membersonly
 *   Set this to TRUE to exclude the 'anonymous' role.
 * @param $permission
 *   A string containing a permission. If set, only roles containing that
 *   permission are returned.
 *
 * @return
 *   An associative array with the role id as the key and the role object as
 *   value.
 */
function user_roles($membersonly = FALSE, $permission = NULL) {
  $user_roles = &drupal_static(__FUNCTION__);

  // Do not cache roles for specific permissions. This data is not requested
  // frequently enough to justify the additional memory use.
  if (empty($permission)) {
    $cid = $membersonly ? DRUPAL_AUTHENTICATED_RID : DRUPAL_ANONYMOUS_RID;
    if (isset($user_roles[$cid])) {
      return $user_roles[$cid];
    }
  }

  $roles = entity_load_multiple('user_role');
  if ($membersonly) {
    unset($roles[DRUPAL_ANONYMOUS_RID]);
  }

  if (!empty($permission)) {
    $roles = array_filter($roles, function ($role) use ($permission) {
      return $role->hasPermission($permission);
    });
  }

  if (empty($permission)) {
    $user_roles[$cid] = $roles;
  }

  return $roles;
}

/**
 * Fetches a user role by role ID.
 *
 * @param $rid
 *   A string representing the role ID.
 *
 * @return
 *   A fully-loaded role object if a role with the given ID exists, or NULL
 *   otherwise.
 */
function user_role_load($rid) {
  return entity_load('user_role', $rid);
}

/**
 * Determine the modules that permissions belong to.
 *
 * @return
 *   An associative array in the format $permission => $module.
 */
function user_permission_get_modules() {
  $permissions = array();
  foreach (Drupal::moduleHandler()->getImplementations('permission') as $module) {
    $perms = module_invoke($module, 'permission');
    foreach ($perms as $key => $value) {
      $permissions[$key] = $module;
    }
  }
  return $permissions;
}

/**
 * Change permissions for a user role.
 *
 * This function may be used to grant and revoke multiple permissions at once.
 * For example, when a form exposes checkboxes to configure permissions for a
 * role, the form submit handler may directly pass the submitted values for the
 * checkboxes form element to this function.
 *
 * @param $rid
 *   The ID of a user role to alter.
 * @param $permissions
 *   An associative array, where the key holds the permission name and the value
 *   determines whether to grant or revoke that permission. Any value that
 *   evaluates to TRUE will cause the permission to be granted. Any value that
 *   evaluates to FALSE will cause the permission to be revoked.
 *   @code
 *     array(
 *       'administer nodes' => 0,                // Revoke 'administer nodes'
 *       'administer blocks' => FALSE,           // Revoke 'administer blocks'
 *       'access user profiles' => 1,            // Grant 'access user profiles'
 *       'access content' => TRUE,               // Grant 'access content'
 *       'access comments' => 'access comments', // Grant 'access comments'
 *     )
 *   @endcode
 *   Existing permissions are not changed, unless specified in $permissions.
 *
 * @see user_role_grant_permissions()
 * @see user_role_revoke_permissions()
 */
function user_role_change_permissions($rid, array $permissions = array()) {
  // Grant new permissions for the role.
  $grant = array_filter($permissions);
  if (!empty($grant)) {
    user_role_grant_permissions($rid, array_keys($grant));
  }
  // Revoke permissions for the role.
  $revoke = array_diff_assoc($permissions, $grant);
  if (!empty($revoke)) {
    user_role_revoke_permissions($rid, array_keys($revoke));
  }
}

/**
 * Grant permissions to a user role.
 *
 * @param $rid
 *   The ID of a user role to alter.
 * @param $permissions
 *   A list of permission names to grant.
 *
 * @see user_role_change_permissions()
 * @see user_role_revoke_permissions()
 */
function user_role_grant_permissions($rid, array $permissions = array()) {
  // Grant new permissions for the role.
  $role = entity_load('user_role', $rid);
  foreach ($permissions as $permission) {
    $role->grantPermission($permission);
  }
  $role->save();
}

/**
 * Revoke permissions from a user role.
 *
 * @param $rid
 *   The ID of a user role to alter.
 * @param $permissions
 *   A list of permission names to revoke.
 *
 * @see user_role_change_permissions()
 * @see user_role_grant_permissions()
 */
function user_role_revoke_permissions($rid, array $permissions = array()) {
  // Revoke permissions for the role.
  $role = entity_load('user_role', $rid);
  foreach ($permissions as $permission) {
    $role->revokePermission($permission);
  }
  $role->save();
}

function user_multiple_cancel_confirm($form, &$form_state) {
  // Retrieve the accounts to be canceled from the temp store.
  $accounts = Drupal::service('user.tempstore')->get('user_user_operations_cancel')->get($GLOBALS['user']->id());
  $form['accounts'] = array('#prefix' => '<ul>', '#suffix' => '</ul>', '#tree' => TRUE);
  foreach ($accounts as $account) {
    $uid = $account->id();
    // Prevent user 1 from being canceled.
    if ($uid <= 1) {
      continue;
    }
    $form['accounts'][$uid] = array(
      '#type' => 'hidden',
      '#value' => $uid,
      '#prefix' => '<li>',
      '#suffix' => check_plain($account->getUsername()) . "</li>\n",
    );
  }

  // Output a notice that user 1 cannot be canceled.
  if (isset($accounts[1])) {
    $redirect = (count($accounts) == 1);
    $message = t('The user account %name cannot be cancelled.', array('%name' => $accounts[1]->name->value));
    drupal_set_message($message, $redirect ? 'error' : 'warning');
    // If only user 1 was selected, redirect to the overview.
    if ($redirect) {
      return new RedirectResponse(url('admin/people', array('absolute' => TRUE)));
    }
  }

  $form['operation'] = array('#type' => 'hidden', '#value' => 'cancel');

  form_load_include($form_state, 'inc', 'user', 'user.pages');
  $form['user_cancel_method'] = array(
    '#type' => 'radios',
    '#title' => t('When cancelling these accounts'),
  );
  $form['user_cancel_method'] += user_cancel_methods();

  // Allow to send the account cancellation confirmation mail.
  $form['user_cancel_confirm'] = array(
    '#type' => 'checkbox',
    '#title' => t('Require e-mail confirmation to cancel account.'),
    '#default_value' => FALSE,
    '#description' => t('When enabled, the user must confirm the account cancellation via e-mail.'),
  );
  // Also allow to send account canceled notification mail, if enabled.
  $form['user_cancel_notify'] = array(
    '#type' => 'checkbox',
    '#title' => t('Notify user when account is canceled.'),
    '#default_value' => FALSE,
    '#access' => Drupal::config('user.settings')->get('notify.status_canceled'),
    '#description' => t('When enabled, the user will receive an e-mail notification after the account has been cancelled.'),
  );

  return confirm_form($form,
                      t('Are you sure you want to cancel these user accounts?'),
                      'admin/people', t('This action cannot be undone.'),
                      t('Cancel accounts'), t('Cancel'));
}

/**
 * Submit handler for mass-account cancellation form.
 *
 * @see user_multiple_cancel_confirm()
 * @see user_cancel_confirm_form_submit()
 */
function user_multiple_cancel_confirm_submit($form, &$form_state) {
  global $user;

  // Clear out the accounts from the temp store.
  Drupal::service('user.tempstore')->get('user_user_operations_cancel')->delete($user->id());
  if ($form_state['values']['confirm']) {
    foreach ($form_state['values']['accounts'] as $uid => $value) {
      // Prevent programmatic form submissions from cancelling user 1.
      if ($uid <= 1) {
        continue;
      }
      // Prevent user administrators from deleting themselves without confirmation.
      if ($uid == $user->id()) {
        $admin_form_state = $form_state;
        unset($admin_form_state['values']['user_cancel_confirm']);
        // The $user global is not a complete user entity, so load the full
        // entity.
        $admin_form_state['values']['_account'] = user_load($user->id());
        user_cancel_confirm_form_submit(array(), $admin_form_state);
      }
      else {
        user_cancel($form_state['values'], $uid, $form_state['values']['user_cancel_method']);
      }
    }
  }
  $form_state['redirect'] = 'admin/people';
}

/**
 * Returns HTML for a user signature.
 *
 * @param $variables
 *   An associative array containing:
 *   - signature: The user's signature.
 *
 * @ingroup themeable
 */
function theme_user_signature($variables) {
  $signature = $variables['signature'];
  $output = '';

  if ($signature) {
    $output .= '<div class="clear">';
    $output .= '<div>—</div>';
    $output .= $signature;
    $output .= '</div>';
  }

  return $output;
}

/**
 * Conditionally create and send a notification email when a certain
 * operation happens on the given user account.
 *
 * @see user_mail_tokens()
 * @see drupal_mail()
 *
 * @param $op
 *   The operation being performed on the account. Possible values:
 *   - 'register_admin_created': Welcome message for user created by the admin.
 *   - 'register_no_approval_required': Welcome message when user
 *     self-registers.
 *   - 'register_pending_approval': Welcome message, user pending admin
 *     approval.
 *   - 'password_reset': Password recovery request.
 *   - 'status_activated': Account activated.
 *   - 'status_blocked': Account blocked.
 *   - 'cancel_confirm': Account cancellation request.
 *   - 'status_canceled': Account canceled.
 *
 * @param $account
 *   The user object of the account being notified. Must contain at
 *   least the fields 'uid', 'name', and 'mail'.
 * @param $langcode
 *   Optional language code to use for the notification, overriding account
 *   language.
 *
 * @return
 *   The return value from drupal_mail_system()->mail(), if ends up being
 *   called.
 */
function _user_mail_notify($op, $account, $langcode = NULL) {
  // By default, we always notify except for canceled and blocked.
  $notify = Drupal::config('user.settings')->get('notify.' . $op);
  if ($notify || ($op != 'status_canceled' && $op != 'status_blocked')) {
    $params['account'] = $account;
    $langcode = $langcode ? $langcode : $account->getPreferredLangcode();
    // Get the custom site notification email to use as the from email address
    // if it has been set.
    $site_mail = Drupal::config('system.site')->get('mail_notification');
    // If the custom site notification email has not been set, we use the site
    // default for this.
    if (empty($site_mail)) {
      $site_mail = Drupal::config('system.site')->get('mail');
    }
    if (empty($site_mail)) {
      $site_mail = ini_get('sendmail_from');
    }
    $mail = drupal_mail('user', $op, $account->getEmail(), $langcode, $params, $site_mail);
    if ($op == 'register_pending_approval') {
      // If a user registered requiring admin approval, notify the admin, too.
      // We use the site default language for this.
      drupal_mail('user', 'register_pending_approval_admin', $site_mail, language_default()->id, $params);
    }
  }
  return empty($mail) ? NULL : $mail['result'];
}

/**
 * Form element process handler for client-side password validation.
 *
 * This #process handler is automatically invoked for 'password_confirm' form
 * elements to add the JavaScript and string translations for dynamic password
 * validation.
 *
 * @see system_element_info()
 */
function user_form_process_password_confirm($element) {
  $password_settings = array(
    'confirmTitle' => t('Passwords match:'),
    'confirmSuccess' => t('yes'),
    'confirmFailure' => t('no'),
    'showStrengthIndicator' => FALSE,
  );

  if (Drupal::config('user.settings')->get('password_strength')) {

    global $user;
    $password_settings['showStrengthIndicator'] = TRUE;
    $password_settings += array(
      'strengthTitle' => t('Password strength:'),
      'hasWeaknesses' => t('To make your password stronger:'),
      'tooShort' => t('Make it at least 6 characters'),
      'addLowerCase' => t('Add lowercase letters'),
      'addUpperCase' => t('Add uppercase letters'),
      'addNumbers' => t('Add numbers'),
      'addPunctuation' => t('Add punctuation'),
      'sameAsUsername' => t('Make it different from your username'),
      'weak' => t('Weak'),
      'fair' => t('Fair'),
      'good' => t('Good'),
      'strong' => t('Strong'),
      'username' => $user->getUsername(),
    );
  }

  $js_settings = array(
    'password' => $password_settings,
  );

  $element['#attached']['library'][] = array('user', 'drupal.user');
  // Ensure settings are only added once per page.
  static $already_added = FALSE;
  if (!$already_added) {
    $already_added = TRUE;
    $element['#attached']['js'][] = array('data' => $js_settings, 'type' => 'setting');
  }

  return $element;
}

/**
 * Implements hook_node_load().
 *
 * @todo Deprecated by $node->author, attached in
 *   \Drupal\node\NodeRenderController::buildContent(). Update code that
 *   depends on these properties.
 */
function user_node_load($nodes, $types) {
  // Build an array of all uids for node authors, keyed by nid.
  $uids = array();
  foreach ($nodes as $nid => $node) {
    $uids[$nid] = $node->uid;
  }

  // Fetch name and data for these users.
  $user_names = db_query("SELECT uid, name FROM {users} WHERE uid IN (:uids)", array(':uids' => $uids))->fetchAllKeyed();

  // Add these values back into the node objects.
  foreach ($uids as $nid => $uid) {
    $nodes[$nid]->name = $user_names[$uid];
  }
}

/**
 * Implements hook_modules_installed().
 */
function user_modules_installed($modules) {
  // Assign all available permissions to the administrator role.
  $rid = Drupal::config('user.settings')->get('admin_role');
  if ($rid) {
    $permissions = array();
    foreach ($modules as $module) {
      if ($module_permissions = module_invoke($module, 'permission')) {
        $permissions = array_merge($permissions, array_keys($module_permissions));
      }
    }
    if (!empty($permissions)) {
      user_role_grant_permissions($rid, $permissions);
    }
  }
}

/**
 * Implements hook_modules_uninstalled().
 */
function user_modules_uninstalled($modules) {
  // Remove any potentially orphan module data stored for users.
  drupal_container()->get('user.data')->delete($modules);
}

/**
 * Saves visitor information as a cookie so it can be reused.
 *
 * @param $values
 *   An array of key/value pairs to be saved into a cookie.
 */
function user_cookie_save(array $values) {
  foreach ($values as $field => $value) {
    // Set cookie for 365 days.
    setrawcookie('Drupal.visitor.' . $field, rawurlencode($value), REQUEST_TIME + 31536000, '/');
  }
}

/**
 * Delete a visitor information cookie.
 *
 * @param $cookie_name
 *   A cookie name such as 'homepage'.
 */
function user_cookie_delete($cookie_name) {
  setrawcookie('Drupal.visitor.' . $cookie_name, '', REQUEST_TIME - 3600, '/');
}

/**
 * Implements hook_file_download_access().
 */
function user_file_download_access($field, EntityInterface $entity, File $file) {
  if ($entity->entityType() == 'user') {
    return $entity->access('view');
  }
}

/**
 * Implements hook_toolbar().
 */
function user_toolbar() {
  global $user;

  // Add logout & user account links or login link.
  if ($user->isAuthenticated()) {
    $links = array(
      'account' => array(
        'title' => t('View profile'),
        'href' => 'user',
        'html' => TRUE,
        'attributes' => array(
          'title' => t('User account'),
        ),
      ),
      'account_edit' => array(
        'title' => t('Edit profile'),
        'href' => 'user/' . $user->id() . '/edit',
        'html' => TRUE,
        'attributes' => array(
          'title' => t('Edit user account'),
        ),
      ),
      'logout' => array(
        'title' => t('Log out'),
        'href' => 'user/logout',
      ),
    );
  }
  else {
     $links = array(
      'login' => array(
        'title' => t('Log in'),
        'href' => 'user',
      ),
    );
  }

  $items['user'] = array(
    '#type' => 'toolbar_item',
    'tab' => array(
      '#type' => 'link',
      '#title' => $user->getUsername(),
      '#href' => 'user',
      '#options' => array(
        'attributes' => array(
          'title' => t('My account'),
          'class' => array('toolbar-icon', 'toolbar-icon-user'),
        ),
      ),
    ),
    'tray' => array(
      '#heading' => t('User account actions'),
      'user_links' => array(
        '#theme' => 'links__toolbar_user',
        '#links' => $links,
        '#attributes' => array(
          'class' => array('menu'),
        ),
      ),
    ),
    '#weight' => 100,
  );

  return $items;
}

/**
 * Implements hook_library_info().
 */
function user_library_info() {
  $libraries['drupal.user'] = array(
    'title' => 'User',
    'version' => VERSION,
    'js' => array(
      drupal_get_path('module', 'user') . '/user.js' => array(),
    ),
    'css' => array(
      drupal_get_path('module', 'user') . '/css/user.module.css' => array(),
    ),
    'dependencies' => array(
      array('system', 'jquery'),
      array('system', 'drupal'),
      array('system', 'jquery.once'),
    ),
  );

  $libraries['drupal.user.permissions'] = array(
    'title' => 'User permissions',
    'version' => VERSION,
    'js' => array(
      drupal_get_path('module', 'user') . '/user.permissions.js' => array(),
    ),
    'dependencies' => array(
      array('system', 'jquery'),
      array('system', 'drupal'),
      array('system', 'drupalSettings'),
    ),
  );

  return $libraries;
}

/**
 * Logs the current user out.
 */
function user_logout() {
  global $user;

  watchdog('user', 'Session closed for %name.', array('%name' => $user->getUsername()));

  Drupal::moduleHandler()->invokeAll('user_logout', array($user));

  // Destroy the current session, and reset $user to the anonymous user.
  session_destroy();
}
